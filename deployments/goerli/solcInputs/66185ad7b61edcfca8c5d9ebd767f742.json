{
  "language": "Solidity",
  "sources": {
    "contracts/Connectivity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ConnectivityVerifier.sol\";\n\n/// @title Connectivity.sol\n/// @author benhooper.eth\n/// @notice The demo contract for this repository\ncontract Connectivity {\n    // the verifier contract (generated by running nargo codegen-verifier)\n    ConnectivityVerifier public verifier;\n\n    // tracking all used proofs\n    mapping(bytes32 => bool) public usedProofs;\n\n    // the constructor takes the address of the verifier contract\n    constructor(address _verifier) {\n        verifier = ConnectivityVerifier(_verifier);\n    }\n\n    // the submitProof function takes a proof and verifies it using our deployed verifier contract\n    function submitProof(bytes calldata _proof) public {\n        // verify the proof - if invalid, the transaction will revert\n        require(verifier.verify(_proof), \"Proof is invalid\");\n\n        // hash the proof and store it\n        bytes32 proofHash = keccak256(_proof);\n        usedProofs[proofHash] = true;\n\n        // ... this is where you'd call your contract logic\n    }\n\n    // helper function used to determine if a proof has been used or not\n    function isProofUsed(bytes32 _proof) public view returns (bool) {\n        return usedProofs[_proof];\n    }\n}\n"
    },
    "contracts/ConnectivityVerifier.sol": {
      "content": "\n// SPDX-License-Identifier: GPL-2.0-only\n// Copyright 2020 Spilsbury Holdings Ltd\n\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\n/**\n * @title Turbo Plonk proof verification contract\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\n *\n * Copyright 2020 Spilsbury Holdings Ltd\n *\n * Licensed under the GNU General Public License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\ncontract ConnectivityVerifier { \n    using Bn254Crypto for Types.G1Point;\n    using Bn254Crypto for Types.G2Point;\n    using Transcript for Transcript.TranscriptData;\n\n    /**\n        Calldata formatting:\n\n        0x00 - 0x04 : function signature\n        0x04 - 0x24 : proof_data pointer (location in calldata that contains the proof_data array)\n        0x44 - 0x64 : length of `proof_data` array\n        0x64 - ???? : array containing our zk proof data\n    **/\n    /**\n     * @dev Verify a Plonk proof\n     * @param - array of serialized proof data\n     */\n    function verify(bytes calldata)\n        external\n        view\n        returns (bool result)\n    {\n\n        Types.VerificationKey memory vk = get_verification_key();\n        uint256 num_public_inputs = vk.num_inputs;\n\n        // parse the input calldata and construct a Proof object\n        Types.Proof memory decoded_proof = deserialize_proof(\n            num_public_inputs,\n            vk\n        );\n\n        Transcript.TranscriptData memory transcript;\n        transcript.generate_initial_challenge(vk.circuit_size, vk.num_inputs);\n\n        // reconstruct the beta, gamma, alpha and zeta challenges\n        Types.ChallengeTranscript memory challenges;\n        transcript.generate_beta_gamma_challenges(challenges, vk.num_inputs);\n        transcript.generate_alpha_challenge(challenges, decoded_proof.Z);\n        transcript.generate_zeta_challenge(\n            challenges,\n            decoded_proof.T1,\n            decoded_proof.T2,\n            decoded_proof.T3,\n            decoded_proof.T4\n        );\n\n        /**\n         * Compute all inverses that will be needed throughout the program here.\n         *\n         * This is an efficiency improvement - it allows us to make use of the batch inversion Montgomery trick,\n         * which allows all inversions to be replaced with one inversion operation, at the expense of a few\n         * additional multiplications\n         **/\n        (uint256 r_0, uint256 L1) = evalaute_field_operations(\n            decoded_proof,\n            vk,\n            challenges\n        );\n        decoded_proof.r_0 = r_0;\n\n        // reconstruct the nu and u challenges\n        // Need to change nu and u according to the simplified Plonk\n        transcript.generate_nu_challenges(challenges, vk.num_inputs);\n\n        transcript.generate_separator_challenge(\n            challenges,\n            decoded_proof.PI_Z,\n            decoded_proof.PI_Z_OMEGA\n        );\n\n        //reset 'alpha base'\n        challenges.alpha_base = challenges.alpha;\n        // Computes step 9 -> [D]_1\n        Types.G1Point memory linearised_contribution = PolynomialEval\n            .compute_linearised_opening_terms(\n                challenges,\n                L1,\n                vk,\n                decoded_proof\n            );\n        // Computes step 10 -> [F]_1\n        Types.G1Point memory batch_opening_commitment = PolynomialEval\n            .compute_batch_opening_commitment(\n                challenges,\n                vk,\n                linearised_contribution,\n                decoded_proof\n            );\n\n        uint256 batch_evaluation_g1_scalar = PolynomialEval\n            .compute_batch_evaluation_scalar_multiplier(\n                decoded_proof,\n                challenges\n            );\n\n        result = perform_pairing(\n            batch_opening_commitment,\n            batch_evaluation_g1_scalar,\n            challenges,\n            decoded_proof,\n            vk\n        );\n        require(result, \"Proof failed\");\n    }\n\n    \n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\n        Types.VerificationKey memory vk;\n\n        assembly {\n            mstore(add(vk, 0x00), 16) // vk.circuit_size\n            mstore(add(vk, 0x20), 1) // vk.num_inputs\n            mstore(add(vk, 0x40),0x21082ca216cbbf4e1c6e4f4594dd508c996dfbe1174efb98b11509c6e306460b) // vk.work_root\n            mstore(add(vk, 0x60),0x2d5e098bb31e86271ccb415b196942d755b0a9c3f21dd9882fa3d63ab1000001) // vk.domain_inverse\n            mstore(add(vk, 0x80),0x02e40daf409556c02bfc85eb303402b774954d30aeb0337eb85a71e6373428de) // vk.work_root_inverse\n            mstore(mload(add(vk, 0xa0)), 0x3053d3284c77d41e8df7fe97a486a15d1f4b728f6d3ed7a2bd230254da9f54ae)//vk.Q1\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x2f94dd5d2e27f84ae958f2d0a4b73b64ca6189cf252a45f41575445113e7db3c)\n            mstore(mload(add(vk, 0xc0)), 0x18dabc1bfd7e9441b50c41ef73979b73a9595e67fce8baa81f51eff397bd8024)//vk.Q2\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x224598af4cc0daec322b79f679556600b479ac8c1f70becc6adafbd522c1c218)\n            mstore(mload(add(vk, 0xe0)), 0x264ab6636e5c1afeb02a26cd15a480b3309f355223871f4b27a27a6813a3e13c)//vk.Q3\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x1d3c54da6aebfcda2e408482a9fe4052123c71d37f88730df991f4d26b297d67)\n            mstore(mload(add(vk, 0x100)), 0x2950076760523510abcfe90fa550b964e84b338f73af5222cdbbaefdacd4484e)//vk.Q4\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x2e4e3e272c7b78ad894559812d7766e05615a8f7050a43d7ed1367adf30a9319)\n            mstore(mload(add(vk, 0x120)), 0x2950076760523510abcfe90fa550b964e84b338f73af5222cdbbaefdacd4484e)//vk.Q5\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x2e4e3e272c7b78ad894559812d7766e05615a8f7050a43d7ed1367adf30a9319)\n            mstore(mload(add(vk, 0x140)), 0x0e842328da2cff90634b806ad77cd024ac366faa6125c2099dcb41411f6a1089)//vk.QM\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x2d2c44d1219e6f8bd6ee7623a5e610fa39681975ee97bb361d484ca072146027)\n            mstore(mload(add(vk, 0x160)), 0x1a11bdab573373566e3a886afef99b7c839d756b6b6ccc5e19e602eaa8ec921d)//vk.QC\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x112413bd08118767f9f24a2c2f3b3fc934b55f6d6e05aa9ae58e58788566b753)\n            mstore(mload(add(vk, 0x180)), 0x20c490fd11d21e23b135faaac8d178e13e874c709d3569e9a6291b5e9bae832b)//vk.QARITH\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x0e283862c50f9719c7bbbd43b29d2171dd76373e50dfcb8132f2c3610b9324e9)\n            mstore(mload(add(vk, 0x1a0)), 0x2950076760523510abcfe90fa550b964e84b338f73af5222cdbbaefdacd4484e)//vk.QECC\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x2e4e3e272c7b78ad894559812d7766e05615a8f7050a43d7ed1367adf30a9319)\n            mstore(mload(add(vk, 0x1c0)), 0x2950076760523510abcfe90fa550b964e84b338f73af5222cdbbaefdacd4484e)//vk.QRANGE\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x2e4e3e272c7b78ad894559812d7766e05615a8f7050a43d7ed1367adf30a9319)\n            mstore(mload(add(vk, 0x1e0)), 0x2950076760523510abcfe90fa550b964e84b338f73af5222cdbbaefdacd4484e)//vk.QLOGIC\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x2e4e3e272c7b78ad894559812d7766e05615a8f7050a43d7ed1367adf30a9319)\n            mstore(mload(add(vk, 0x200)), 0x2ebd09da194fe43b4c1109a2a5832b67bc40427c71febae4288243d77869750f)//vk.SIGMA1\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x2cb10d85cc7cc54fa057840ebe26ef68496a93cf04692ed9251c9408aa04bf63)\n            mstore(mload(add(vk, 0x220)), 0x27f0e060d6b76cb4be9114daa88af23568e54623860467b0c37361c86bf55e11)//vk.SIGMA2\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x249f464b8410f8706a130f3aa8e3b9f042da5cd4052eb67189db874c76f7f57a)\n            mstore(mload(add(vk, 0x240)), 0x1cede5533face92ab95d6c516ed703868ab9d008d56267d7b5bcc1c08198c152)//vk.SIGMA3\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x2b9945db668f103855ac323354d62c8634eab28f9e0f50fb6f4176d103cbc9c2)\n            mstore(mload(add(vk, 0x260)), 0x1a2b1403291d80ea6ffdb22226c32d0409288e288945cca26a7eabdfe9d8e5be)//vk.SIGMA4\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x0c8527e6817b660e4b923b9c7d2b4b2c2b06fd8cf6be63153347e44093ea6dd1)\n            mstore(add(vk, 0x280), 0x00) // vk.contains_recursive_proof\n            mstore(add(vk, 0x2a0), 0) // vk.recursive_proof_public_input_indices\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\n        }\n        return vk;\n    }\n\n\n    /**\n     * @dev Compute partial state of the verifier, specifically: public input delta evaluation, zero polynomial\n     * evaluation, the lagrange evaluations and the quotient polynomial evaluations\n     *\n     * Note: This uses the batch inversion Montgomery trick to reduce the number of\n     * inversions, and therefore the number of calls to the bn128 modular exponentiation\n     * precompile.\n     *\n     * Specifically, each function call: compute_public_input_delta() etc. at some point needs to invert a\n     * value to calculate a denominator in a fraction. Instead of performing this inversion as it is needed, we\n     * instead 'save up' the denominator calculations. The inputs to this are returned from the various functions\n     * and then we perform all necessary inversions in one go at the end of `evalaute_field_operations()`. This\n     * gives us the various variables that need to be returned.\n     *\n     * @param decoded_proof - deserialised proof\n     * @param vk - verification key\n     * @param challenges - all challenges (alpha, beta, gamma, zeta, nu[NUM_NU_CHALLENGES], u) stored in\n     * ChallengeTranscript struct form\n     * @return quotient polynomial evaluation (field element) and lagrange 1 evaluation (field element)\n     */\n    function evalaute_field_operations(\n        Types.Proof memory decoded_proof,\n        Types.VerificationKey memory vk,\n        Types.ChallengeTranscript memory challenges\n    ) internal view returns (uint256, uint256) {\n        uint256 public_input_delta;\n        uint256 zero_polynomial_eval;\n        uint256 l_start;\n        uint256 l_end;\n        {\n            (\n                uint256 public_input_numerator,\n                uint256 public_input_denominator\n            ) = PolynomialEval.compute_public_input_delta(challenges, vk);\n\n            (\n                uint256 vanishing_numerator,\n                uint256 vanishing_denominator,\n                uint256 lagrange_numerator,\n                uint256 l_start_denominator,\n                uint256 l_end_denominator\n            ) = PolynomialEval.compute_lagrange_and_vanishing_fractions(\n                    vk,\n                    challenges.zeta\n                );\n\n            (\n                zero_polynomial_eval,\n                public_input_delta,\n                l_start,\n                l_end\n            ) = PolynomialEval.compute_batch_inversions(\n                public_input_numerator,\n                public_input_denominator,\n                vanishing_numerator,\n                vanishing_denominator,\n                lagrange_numerator,\n                l_start_denominator,\n                l_end_denominator\n            );\n            vk.zero_polynomial_eval = zero_polynomial_eval;\n        }\n\n        uint256 r_0 = PolynomialEval.compute_linear_polynomial_constant(\n            zero_polynomial_eval,\n            public_input_delta,\n            challenges,\n            l_start,\n            l_end,\n            decoded_proof\n        );\n\n        return (r_0, l_start);\n    }\n\n    /**\n     * @dev Perform the pairing check\n     * @param batch_opening_commitment - G1 point representing the calculated batch opening commitment\n     * @param batch_evaluation_g1_scalar - uint256 representing the batch evaluation scalar multiplier to be applied to the G1 generator point\n     * @param challenges - all challenges (alpha, beta, gamma, zeta, nu[NUM_NU_CHALLENGES], u) stored in\n     * ChallengeTranscript struct form\n     * @param vk - verification key\n     * @param decoded_proof - deserialised proof\n     * @return bool specifying whether the pairing check was successful\n     */\n    function perform_pairing(\n        Types.G1Point memory batch_opening_commitment,\n        uint256 batch_evaluation_g1_scalar,\n        Types.ChallengeTranscript memory challenges,\n        Types.Proof memory decoded_proof,\n        Types.VerificationKey memory vk\n    ) internal view returns (bool) {\n        uint256 u = challenges.u;\n        bool success;\n        uint256 p = Bn254Crypto.r_mod;\n        Types.G1Point memory rhs;\n        Types.G1Point memory PI_Z_OMEGA = decoded_proof.PI_Z_OMEGA;\n        Types.G1Point memory PI_Z = decoded_proof.PI_Z;\n        PI_Z.validateG1Point();\n        PI_Z_OMEGA.validateG1Point();\n\n        // rhs = zeta.[PI_Z] + u.zeta.omega.[PI_Z_OMEGA] + [batch_opening_commitment] - batch_evaluation_g1_scalar.[1]\n        // scope this block to prevent stack depth errors\n        {\n            uint256 zeta = challenges.zeta;\n            uint256 pi_z_omega_scalar = vk.work_root;\n            assembly {\n                pi_z_omega_scalar := mulmod(pi_z_omega_scalar, zeta, p)\n                pi_z_omega_scalar := mulmod(pi_z_omega_scalar, u, p)\n                batch_evaluation_g1_scalar := sub(p, batch_evaluation_g1_scalar)\n\n                // store accumulator point at mptr\n                let mPtr := mload(0x40)\n\n                // set accumulator = batch_opening_commitment\n                mstore(mPtr, mload(batch_opening_commitment))\n                mstore(\n                    add(mPtr, 0x20),\n                    mload(add(batch_opening_commitment, 0x20))\n                )\n\n                // compute zeta.[PI_Z] and add into accumulator\n                mstore(add(mPtr, 0x40), mload(PI_Z))\n                mstore(add(mPtr, 0x60), mload(add(PI_Z, 0x20)))\n                mstore(add(mPtr, 0x80), zeta)\n                success := staticcall(\n                    gas(),\n                    7,\n                    add(mPtr, 0x40),\n                    0x60,\n                    add(mPtr, 0x40),\n                    0x40\n                )\n                success := and(\n                    success,\n                    staticcall(gas(), 6, mPtr, 0x80, mPtr, 0x40)\n                )\n\n                // compute u.zeta.omega.[PI_Z_OMEGA] and add into accumulator\n                mstore(add(mPtr, 0x40), mload(PI_Z_OMEGA))\n                mstore(add(mPtr, 0x60), mload(add(PI_Z_OMEGA, 0x20)))\n                mstore(add(mPtr, 0x80), pi_z_omega_scalar)\n                success := and(\n                    success,\n                    staticcall(\n                        gas(),\n                        7,\n                        add(mPtr, 0x40),\n                        0x60,\n                        add(mPtr, 0x40),\n                        0x40\n                    )\n                )\n                success := and(\n                    success,\n                    staticcall(gas(), 6, mPtr, 0x80, mPtr, 0x40)\n                )\n\n                // compute -batch_evaluation_g1_scalar.[1]\n                mstore(add(mPtr, 0x40), 0x01) // hardcoded generator point (1, 2)\n                mstore(add(mPtr, 0x60), 0x02)\n                mstore(add(mPtr, 0x80), batch_evaluation_g1_scalar)\n                success := and(\n                    success,\n                    staticcall(\n                        gas(),\n                        7,\n                        add(mPtr, 0x40),\n                        0x60,\n                        add(mPtr, 0x40),\n                        0x40\n                    )\n                )\n\n                // add -batch_evaluation_g1_scalar.[1] and the accumulator point, write result into rhs\n                success := and(\n                    success,\n                    staticcall(gas(), 6, mPtr, 0x80, rhs, 0x40)\n                )\n            }\n        }\n\n        Types.G1Point memory lhs;\n        assembly {\n            // store accumulator point at mptr\n            let mPtr := mload(0x40)\n\n            // copy [PI_Z] into mPtr\n            mstore(mPtr, mload(PI_Z))\n            mstore(add(mPtr, 0x20), mload(add(PI_Z, 0x20)))\n\n            // compute u.[PI_Z_OMEGA] and write to (mPtr + 0x40)\n            mstore(add(mPtr, 0x40), mload(PI_Z_OMEGA))\n            mstore(add(mPtr, 0x60), mload(add(PI_Z_OMEGA, 0x20)))\n            mstore(add(mPtr, 0x80), u)\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(mPtr, 0x40),\n                    0x60,\n                    add(mPtr, 0x40),\n                    0x40\n                )\n            )\n\n            // add [PI_Z] + u.[PI_Z_OMEGA] and write result into lhs\n            success := and(success, staticcall(gas(), 6, mPtr, 0x80, lhs, 0x40))\n        }\n\n        // negate lhs y-coordinate\n        uint256 q = Bn254Crypto.p_mod;\n        assembly {\n            mstore(add(lhs, 0x20), sub(q, mload(add(lhs, 0x20))))\n        }\n\n        if (vk.contains_recursive_proof) {\n            // If the proof itself contains an accumulated proof,\n            // we will have extracted two G1 elements `recursive_P1`, `recursive_p2` from the public inputs\n\n            // We need to evaluate that e(recursive_P1, [x]_2) == e(recursive_P2, [1]_2) to finish verifying the inner proof\n            // We do this by creating a random linear combination between (lhs, recursive_P1) and (rhs, recursivee_P2)\n            // That way we still only need to evaluate one pairing product\n\n            // We use `challenge.u * challenge.u` as the randomness to create a linear combination\n            // challenge.u is produced by hashing the entire transcript, which contains the public inputs (and by extension the recursive proof)\n\n            // i.e. [lhs] = [lhs] + u.u.[recursive_P1]\n            //      [rhs] = [rhs] + u.u.[recursive_P2]\n            Types.G1Point memory recursive_P1 = decoded_proof.recursive_P1;\n            Types.G1Point memory recursive_P2 = decoded_proof.recursive_P2;\n            recursive_P1.validateG1Point();\n            recursive_P2.validateG1Point();\n            assembly {\n                let mPtr := mload(0x40)\n\n                // compute u.u.[recursive_P1]\n                mstore(mPtr, mload(recursive_P1))\n                mstore(add(mPtr, 0x20), mload(add(recursive_P1, 0x20)))\n                mstore(add(mPtr, 0x40), mulmod(u, u, p)) // separator_challenge = u * u\n                success := and(\n                    success,\n                    staticcall(gas(), 7, mPtr, 0x60, add(mPtr, 0x60), 0x40)\n                )\n\n                // compute u.u.[recursive_P2] (u*u is still in memory at (mPtr + 0x40), no need to re-write it)\n                mstore(mPtr, mload(recursive_P2))\n                mstore(add(mPtr, 0x20), mload(add(recursive_P2, 0x20)))\n                success := and(\n                    success,\n                    staticcall(gas(), 7, mPtr, 0x60, mPtr, 0x40)\n                )\n\n                // compute u.u.[recursiveP2] + rhs and write into rhs\n                mstore(add(mPtr, 0xa0), mload(rhs))\n                mstore(add(mPtr, 0xc0), mload(add(rhs, 0x20)))\n                success := and(\n                    success,\n                    staticcall(gas(), 6, add(mPtr, 0x60), 0x80, rhs, 0x40)\n                )\n\n                // compute u.u.[recursiveP1] + lhs and write into lhs\n                mstore(add(mPtr, 0x40), mload(lhs))\n                mstore(add(mPtr, 0x60), mload(add(lhs, 0x20)))\n                success := and(\n                    success,\n                    staticcall(gas(), 6, mPtr, 0x80, lhs, 0x40)\n                )\n            }\n        }\n\n        require(success, \"perform_pairing G1 operations preamble fail\");\n\n        return Bn254Crypto.pairingProd2(rhs, Bn254Crypto.P2(), lhs, vk.g2_x);\n    }\n\n    /**\n     * @dev Deserialize a proof into a Proof struct\n     * @param num_public_inputs - number of public inputs in the proof. Taken from verification key\n     * @return proof - proof deserialized into the proof struct\n     */\n    function deserialize_proof(\n        uint256 num_public_inputs,\n        Types.VerificationKey memory vk\n    ) internal pure returns (Types.Proof memory proof) {\n        uint256 p = Bn254Crypto.r_mod;\n        uint256 q = Bn254Crypto.p_mod;\n        uint256 data_ptr;\n        uint256 proof_ptr;\n        // first 32 bytes of bytes array contains length, skip it\n        assembly {\n            data_ptr := add(calldataload(0x04), 0x24)\n            proof_ptr := proof\n        }\n\n        if (vk.contains_recursive_proof) {\n            uint256 index_counter = vk.recursive_proof_indices * 32;\n            uint256 x0 = 0;\n            uint256 y0 = 0;\n            uint256 x1 = 0;\n            uint256 y1 = 0;\n            assembly {\n                index_counter := add(index_counter, data_ptr)\n                x0 := calldataload(index_counter)\n                x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\n                x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\n                x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\n                y0 := calldataload(add(index_counter, 0x80))\n                y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\n                y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\n                y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\n                x1 := calldataload(add(index_counter, 0x100))\n                x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\n                x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\n                x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\n                y1 := calldataload(add(index_counter, 0x180))\n                y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\n                y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\n                y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\n            }\n\n            proof.recursive_P1 = Bn254Crypto.new_g1(x0, y0);\n            proof.recursive_P2 = Bn254Crypto.new_g1(x1, y1);\n        }\n\n        assembly {\n            let public_input_byte_length := mul(num_public_inputs, 0x20)\n            data_ptr := add(data_ptr, public_input_byte_length)\n\n            // proof.W1\n            mstore(mload(proof_ptr), mod(calldataload(add(data_ptr, 0x20)), q))\n            mstore(add(mload(proof_ptr), 0x20), mod(calldataload(data_ptr), q))\n\n            // proof.W2\n            mstore(\n                mload(add(proof_ptr, 0x20)),\n                mod(calldataload(add(data_ptr, 0x60)), q)\n            )\n            mstore(\n                add(mload(add(proof_ptr, 0x20)), 0x20),\n                mod(calldataload(add(data_ptr, 0x40)), q)\n            )\n\n            // proof.W3\n            mstore(\n                mload(add(proof_ptr, 0x40)),\n                mod(calldataload(add(data_ptr, 0xa0)), q)\n            )\n            mstore(\n                add(mload(add(proof_ptr, 0x40)), 0x20),\n                mod(calldataload(add(data_ptr, 0x80)), q)\n            )\n\n            // proof.W4\n            mstore(\n                mload(add(proof_ptr, 0x60)),\n                mod(calldataload(add(data_ptr, 0xe0)), q)\n            )\n            mstore(\n                add(mload(add(proof_ptr, 0x60)), 0x20),\n                mod(calldataload(add(data_ptr, 0xc0)), q)\n            )\n\n            // proof.Z\n            mstore(\n                mload(add(proof_ptr, 0x80)),\n                mod(calldataload(add(data_ptr, 0x120)), q)\n            )\n            mstore(\n                add(mload(add(proof_ptr, 0x80)), 0x20),\n                mod(calldataload(add(data_ptr, 0x100)), q)\n            )\n\n            // proof.T1\n            mstore(\n                mload(add(proof_ptr, 0xa0)),\n                mod(calldataload(add(data_ptr, 0x160)), q)\n            )\n            mstore(\n                add(mload(add(proof_ptr, 0xa0)), 0x20),\n                mod(calldataload(add(data_ptr, 0x140)), q)\n            )\n\n            // proof.T2\n            mstore(\n                mload(add(proof_ptr, 0xc0)),\n                mod(calldataload(add(data_ptr, 0x1a0)), q)\n            )\n            mstore(\n                add(mload(add(proof_ptr, 0xc0)), 0x20),\n                mod(calldataload(add(data_ptr, 0x180)), q)\n            )\n\n            // proof.T3\n            mstore(\n                mload(add(proof_ptr, 0xe0)),\n                mod(calldataload(add(data_ptr, 0x1e0)), q)\n            )\n            mstore(\n                add(mload(add(proof_ptr, 0xe0)), 0x20),\n                mod(calldataload(add(data_ptr, 0x1c0)), q)\n            )\n\n            // proof.T4\n            mstore(\n                mload(add(proof_ptr, 0x100)),\n                mod(calldataload(add(data_ptr, 0x220)), q)\n            )\n            mstore(\n                add(mload(add(proof_ptr, 0x100)), 0x20),\n                mod(calldataload(add(data_ptr, 0x200)), q)\n            )\n\n            // proof.w1 to proof.w4\n            mstore(\n                add(proof_ptr, 0x120),\n                mod(calldataload(add(data_ptr, 0x240)), p)\n            )\n            mstore(\n                add(proof_ptr, 0x140),\n                mod(calldataload(add(data_ptr, 0x260)), p)\n            )\n            mstore(\n                add(proof_ptr, 0x160),\n                mod(calldataload(add(data_ptr, 0x280)), p)\n            )\n            mstore(\n                add(proof_ptr, 0x180),\n                mod(calldataload(add(data_ptr, 0x2a0)), p)\n            )\n\n            // proof.sigma1\n            mstore(\n                add(proof_ptr, 0x1a0),\n                mod(calldataload(add(data_ptr, 0x2c0)), p)\n            )\n\n            // proof.sigma2\n            mstore(\n                add(proof_ptr, 0x1c0),\n                mod(calldataload(add(data_ptr, 0x2e0)), p)\n            )\n\n            // proof.sigma3\n            mstore(\n                add(proof_ptr, 0x1e0),\n                mod(calldataload(add(data_ptr, 0x300)), p)\n            )\n\n            // proof.q_arith\n            mstore(\n                add(proof_ptr, 0x200),\n                mod(calldataload(add(data_ptr, 0x320)), p)\n            )\n\n            // proof.q_ecc\n            mstore(\n                add(proof_ptr, 0x220),\n                mod(calldataload(add(data_ptr, 0x340)), p)\n            )\n\n            // proof.q_c\n            mstore(\n                add(proof_ptr, 0x240),\n                mod(calldataload(add(data_ptr, 0x360)), p)\n            )\n\n            // proof.linearization_polynomial\n            // mstore(add(proof_ptr, 0x260), mod(calldataload(add(data_ptr, 0x380)), p))\n\n            // proof.grand_product_at_z_omega\n            mstore(\n                add(proof_ptr, 0x260),\n                mod(calldataload(add(data_ptr, 0x380)), p)\n            )\n\n            // proof.w1_omega to proof.w4_omega\n            mstore(\n                add(proof_ptr, 0x280),\n                mod(calldataload(add(data_ptr, 0x3a0)), p)\n            )\n            mstore(\n                add(proof_ptr, 0x2a0),\n                mod(calldataload(add(data_ptr, 0x3c0)), p)\n            )\n            mstore(\n                add(proof_ptr, 0x2c0),\n                mod(calldataload(add(data_ptr, 0x3e0)), p)\n            )\n            mstore(\n                add(proof_ptr, 0x2e0),\n                mod(calldataload(add(data_ptr, 0x400)), p)\n            )\n\n            // proof.PI_Z\n            //Order of x and y coordinate are reverse in case of serialization\n            mstore(\n                mload(add(proof_ptr, 0x300)),\n                mod(calldataload(add(data_ptr, 0x440)), q)\n            )\n            mstore(\n                add(mload(add(proof_ptr, 0x300)), 0x20),\n                mod(calldataload(add(data_ptr, 0x420)), q)\n            )\n\n            // proof.PI_Z_OMEGA\n            mstore(\n                mload(add(proof_ptr, 0x320)),\n                mod(calldataload(add(data_ptr, 0x480)), q)\n            )\n            mstore(\n                add(mload(add(proof_ptr, 0x320)), 0x20),\n                mod(calldataload(add(data_ptr, 0x460)), q)\n            )\n        }\n    }\n}    \n\n\n\n/**\n * @title Bn254Crypto library used for the fr, g1 and g2 point types\n * @dev Used to manipulate fr, g1, g2 types, perform modular arithmetic on them and call\n * the precompiles add, scalar mul and pairing\n *\n * Notes on optimisations\n * 1) Perform addmod, mulmod etc. in assembly - removes the check that Solidity performs to confirm that\n * the supplied modulus is not 0. This is safe as the modulus's used (r_mod, q_mod) are hard coded\n * inside the contract and not supplied by the user\n */\nlibrary Types {\n    uint256 constant PROGRAM_WIDTH = 4;\n    uint256 constant NUM_NU_CHALLENGES = 11;\n\n    uint256 constant coset_generator0 =\n        0x0000000000000000000000000000000000000000000000000000000000000005;\n    uint256 constant coset_generator1 =\n        0x0000000000000000000000000000000000000000000000000000000000000006;\n    uint256 constant coset_generator2 =\n        0x0000000000000000000000000000000000000000000000000000000000000007;\n\n    // TODO: add external_coset_generator() method to compute this\n    uint256 constant coset_generator7 =\n        0x000000000000000000000000000000000000000000000000000000000000000c;\n\n    struct G1Point {\n        uint256 x;\n        uint256 y;\n    }\n\n    // G2 group element where x \\in Fq2 = x0 * z + x1\n    struct G2Point {\n        uint256 x0;\n        uint256 x1;\n        uint256 y0;\n        uint256 y1;\n    }\n\n    // N>B. Do not re-order these fields! They must appear in the same order as they\n    // appear in the proof data\n    struct Proof {\n        G1Point W1;\n        G1Point W2;\n        G1Point W3;\n        G1Point W4;\n        G1Point Z;\n        G1Point T1;\n        G1Point T2;\n        G1Point T3;\n        G1Point T4;\n        uint256 w1;\n        uint256 w2;\n        uint256 w3;\n        uint256 w4;\n        uint256 sigma1;\n        uint256 sigma2;\n        uint256 sigma3;\n        uint256 q_arith;\n        uint256 q_ecc;\n        uint256 q_c;\n        // uint256 linearization_polynomial;\n        uint256 grand_product_at_z_omega;\n        uint256 w1_omega;\n        uint256 w2_omega;\n        uint256 w3_omega;\n        uint256 w4_omega;\n        G1Point PI_Z;\n        G1Point PI_Z_OMEGA;\n        G1Point recursive_P1;\n        G1Point recursive_P2;\n        //    uint256 quotient_polynomial_eval;\n        uint256 r_0;\n    }\n\n    struct ChallengeTranscript {\n        uint256 alpha_base;\n        uint256 alpha;\n        uint256 zeta;\n        uint256 beta;\n        uint256 gamma;\n        uint256 u;\n        uint256 v0;\n        uint256 v1;\n        uint256 v2;\n        uint256 v3;\n        uint256 v4;\n        uint256 v5;\n        uint256 v6;\n        uint256 v7;\n        uint256 v8;\n        uint256 v9;\n        uint256 v10;\n    }\n\n    struct VerificationKey {\n        uint256 circuit_size;\n        uint256 num_inputs;\n        uint256 work_root;\n        uint256 domain_inverse;\n        uint256 work_root_inverse;\n        G1Point Q1;\n        G1Point Q2;\n        G1Point Q3;\n        G1Point Q4;\n        G1Point Q5;\n        G1Point QM;\n        G1Point QC;\n        G1Point QARITH;\n        G1Point QECC;\n        G1Point QRANGE;\n        G1Point QLOGIC;\n        G1Point SIGMA1;\n        G1Point SIGMA2;\n        G1Point SIGMA3;\n        G1Point SIGMA4;\n        bool contains_recursive_proof;\n        uint256 recursive_proof_indices;\n        G2Point g2_x;\n        // zeta challenge raised to the power of the circuit size.\n        // Not actually part of the verification key, but we put it here to prevent stack depth errors\n        uint256 zeta_pow_n;\n        // necessary fot the simplified plonk\n        uint256 zero_polynomial_eval;\n    }\n}\n    \n    \n\n\n/**\n * @title Bn254 elliptic curve crypto\n * @dev Provides some basic methods to compute bilinear pairings, construct group elements and misc numerical methods\n */\nlibrary Bn254Crypto {\n    uint256 constant p_mod =\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\n    uint256 constant r_mod =\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    // Perform a modular exponentiation. This method is ideal for small exponents (~64 bits or less), as\n    // it is cheaper than using the pow precompile\n    function pow_small(\n        uint256 base,\n        uint256 exponent,\n        uint256 modulus\n    ) internal pure returns (uint256) {\n        uint256 result = 1;\n        uint256 input = base;\n        uint256 count = 1;\n\n        assembly {\n            let endpoint := add(exponent, 0x01)\n            for {\n\n            } lt(count, endpoint) {\n                count := add(count, count)\n            } {\n                if and(exponent, count) {\n                    result := mulmod(result, input, modulus)\n                }\n                input := mulmod(input, input, modulus)\n            }\n        }\n\n        return result;\n    }\n\n    function invert(uint256 fr) internal view returns (uint256) {\n        uint256 output;\n        bool success;\n        uint256 p = r_mod;\n        assembly {\n            let mPtr := mload(0x40)\n            mstore(mPtr, 0x20)\n            mstore(add(mPtr, 0x20), 0x20)\n            mstore(add(mPtr, 0x40), 0x20)\n            mstore(add(mPtr, 0x60), fr)\n            mstore(add(mPtr, 0x80), sub(p, 2))\n            mstore(add(mPtr, 0xa0), p)\n            success := staticcall(gas(), 0x05, mPtr, 0xc0, 0x00, 0x20)\n            output := mload(0x00)\n        }\n        require(success, \"pow precompile call failed!\");\n        return output;\n    }\n\n    function new_g1(uint256 x, uint256 y)\n        internal\n        pure\n        returns (Types.G1Point memory)\n    {\n        uint256 xValue;\n        uint256 yValue;\n        assembly {\n            xValue := mod(x, r_mod)\n            yValue := mod(y, r_mod)\n        }\n        return Types.G1Point(xValue, yValue);\n    }\n\n    function new_g2(\n        uint256 x0,\n        uint256 x1,\n        uint256 y0,\n        uint256 y1\n    ) internal pure returns (Types.G2Point memory) {\n        return Types.G2Point(x0, x1, y0, y1);\n    }\n\n    function P1() internal pure returns (Types.G1Point memory) {\n        return Types.G1Point(1, 2);\n    }\n\n    function P2() internal pure returns (Types.G2Point memory) {\n        return\n            Types.G2Point({\n                x0: 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\n                x1: 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed,\n                y0: 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\n                y1: 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\n            });\n    }\n\n    /// Evaluate the following pairing product:\n    /// e(a1, a2).e(-b1, b2) == 1\n    function pairingProd2(\n        Types.G1Point memory a1,\n        Types.G2Point memory a2,\n        Types.G1Point memory b1,\n        Types.G2Point memory b2\n    ) internal view returns (bool) {\n        validateG1Point(a1);\n        validateG1Point(b1);\n        bool success;\n        uint256 out;\n        assembly {\n            let mPtr := mload(0x40)\n            mstore(mPtr, mload(a1))\n            mstore(add(mPtr, 0x20), mload(add(a1, 0x20)))\n            mstore(add(mPtr, 0x40), mload(a2))\n            mstore(add(mPtr, 0x60), mload(add(a2, 0x20)))\n            mstore(add(mPtr, 0x80), mload(add(a2, 0x40)))\n            mstore(add(mPtr, 0xa0), mload(add(a2, 0x60)))\n\n            mstore(add(mPtr, 0xc0), mload(b1))\n            mstore(add(mPtr, 0xe0), mload(add(b1, 0x20)))\n            mstore(add(mPtr, 0x100), mload(b2))\n            mstore(add(mPtr, 0x120), mload(add(b2, 0x20)))\n            mstore(add(mPtr, 0x140), mload(add(b2, 0x40)))\n            mstore(add(mPtr, 0x160), mload(add(b2, 0x60)))\n            success := staticcall(gas(), 8, mPtr, 0x180, 0x00, 0x20)\n            out := mload(0x00)\n        }\n        require(success, \"Pairing check failed!\");\n        return (out != 0);\n    }\n\n    /**\n     * validate the following:\n     *   x != 0\n     *   y != 0\n     *   x < p\n     *   y < p\n     *   y^2 = x^3 + 3 mod p\n     */\n    function validateG1Point(Types.G1Point memory point) internal pure {\n        bool is_well_formed;\n        uint256 p = p_mod;\n        assembly {\n            let x := mload(point)\n            let y := mload(add(point, 0x20))\n\n            is_well_formed := and(\n                and(and(lt(x, p), lt(y, p)), not(or(iszero(x), iszero(y)))),\n                eq(mulmod(y, y, p), addmod(mulmod(x, mulmod(x, x, p), p), 3, p))\n            )\n        }\n        require(\n            is_well_formed,\n            \"Bn254: G1 point not on curve, or is malformed\"\n        );\n    }\n}\n\n    \n\n\n/**\n * @title Turbo Plonk polynomial evaluation\n * @dev Implementation of Turbo Plonk's polynomial evaluation algorithms\n *\n * Expected to be inherited by `TurboPlonk.sol`\n *\n * Copyright 2020 Spilsbury Holdings Ltd\n *\n * Licensed under the GNU General Public License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\nlibrary PolynomialEval {\n    using Bn254Crypto for Types.G1Point;\n    using Bn254Crypto for Types.G2Point;\n\n    /**\n     * @dev Use batch inversion (so called Montgomery's trick). Circuit size is the domain\n     * Allows multiple inversions to be performed in one inversion, at the expense of additional multiplications\n     *\n     * Returns a struct containing the inverted elements\n     */\n    function compute_batch_inversions(\n        uint256 public_input_delta_numerator,\n        uint256 public_input_delta_denominator,\n        uint256 vanishing_numerator,\n        uint256 vanishing_denominator,\n        uint256 lagrange_numerator,\n        uint256 l_start_denominator,\n        uint256 l_end_denominator\n    )\n        internal\n        view\n        returns (\n            uint256 zero_polynomial_eval,\n            uint256 public_input_delta,\n            uint256 l_start,\n            uint256 l_end\n        )\n    {\n        uint256 mPtr;\n        uint256 p = Bn254Crypto.r_mod;\n        uint256 accumulator = 1;\n        assembly {\n            mPtr := mload(0x40)\n            mstore(0x40, add(mPtr, 0x200))\n        }\n\n        // store denominators in mPtr -> mPtr + 0x80\n        assembly {\n            mstore(mPtr, public_input_delta_denominator) // store denominator\n            mstore(add(mPtr, 0x20), vanishing_denominator) // store denominator\n            mstore(add(mPtr, 0x40), l_start_denominator) // store denominator\n            mstore(add(mPtr, 0x60), l_end_denominator) // store denominator\n\n            // store temporary product terms at mPtr + 0x80 -> mPtr + 0x100\n            mstore(add(mPtr, 0x80), accumulator)\n            accumulator := mulmod(accumulator, mload(mPtr), p)\n            mstore(add(mPtr, 0xa0), accumulator)\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x20)), p)\n            mstore(add(mPtr, 0xc0), accumulator)\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x40)), p)\n            mstore(add(mPtr, 0xe0), accumulator)\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x60)), p)\n        }\n\n        accumulator = Bn254Crypto.invert(accumulator);\n        assembly {\n            {\n                let t0 := mulmod(accumulator, mload(add(mPtr, 0xe0)), p)\n                accumulator := mulmod(accumulator, mload(add(mPtr, 0x60)), p)\n                mstore(add(mPtr, 0x60), t0)\n            }\n            {\n                let t1 := mulmod(accumulator, mload(add(mPtr, 0xc0)), p)\n                accumulator := mulmod(accumulator, mload(add(mPtr, 0x40)), p)\n                mstore(add(mPtr, 0x40), t1)\n            }\n            {\n                let t2 := mulmod(accumulator, mload(add(mPtr, 0xa0)), p)\n                accumulator := mulmod(accumulator, mload(add(mPtr, 0x20)), p)\n                mstore(add(mPtr, 0x20), t2)\n            }\n            {\n                let t3 := mulmod(accumulator, mload(add(mPtr, 0x80)), p)\n                accumulator := mulmod(accumulator, mload(mPtr), p)\n                mstore(mPtr, t3)\n            }\n\n            public_input_delta := mulmod(\n                public_input_delta_numerator,\n                mload(mPtr),\n                p\n            )\n\n            zero_polynomial_eval := mulmod(\n                vanishing_numerator,\n                mload(add(mPtr, 0x20)),\n                p\n            )\n\n            l_start := mulmod(lagrange_numerator, mload(add(mPtr, 0x40)), p)\n\n            l_end := mulmod(lagrange_numerator, mload(add(mPtr, 0x60)), p)\n        }\n    }\n\n    function compute_public_input_delta(\n        Types.ChallengeTranscript memory challenges,\n        Types.VerificationKey memory vk\n    ) internal pure returns (uint256, uint256) {\n        uint256 gamma = challenges.gamma;\n        uint256 work_root = vk.work_root;\n\n        uint256 endpoint = (vk.num_inputs * 0x20) - 0x20;\n        uint256 public_inputs;\n        uint256 root_1 = challenges.beta;\n        uint256 root_2 = challenges.beta;\n        uint256 numerator_value = 1;\n        uint256 denominator_value = 1;\n\n        // we multiply length by 0x20 because our loop step size is 0x20 not 0x01\n        // we subtract 0x20 because our loop is unrolled 2 times an we don't want to overshoot\n\n        // perform this computation in assembly to improve efficiency. We are sensitive to the cost of this loop as\n        // it scales with the number of public inputs\n        uint256 p = Bn254Crypto.r_mod;\n        bool valid = true;\n        assembly {\n            root_1 := mulmod(root_1, 0x05, p)\n            root_2 := mulmod(root_2, 0x07, p)\n            public_inputs := add(calldataload(0x04), 0x24)\n\n            // get public inputs from calldata. N.B. If Contract ABI Changes this code will need to be updated!\n            endpoint := add(endpoint, public_inputs)\n            // Do some loop unrolling to reduce number of conditional jump operations\n            for {\n\n            } lt(public_inputs, endpoint) {\n\n            } {\n                let input0 := calldataload(public_inputs)\n                let N0 := add(root_1, add(input0, gamma))\n                let D0 := add(root_2, N0) // 4x overloaded\n\n                root_1 := mulmod(root_1, work_root, p)\n                root_2 := mulmod(root_2, work_root, p)\n\n                let input1 := calldataload(add(public_inputs, 0x20))\n                let N1 := add(root_1, add(input1, gamma))\n\n                denominator_value := mulmod(\n                    mulmod(D0, denominator_value, p),\n                    add(N1, root_2),\n                    p\n                )\n                numerator_value := mulmod(mulmod(N1, N0, p), numerator_value, p)\n\n                root_1 := mulmod(root_1, work_root, p)\n                root_2 := mulmod(root_2, work_root, p)\n\n                valid := and(valid, and(lt(input0, p), lt(input1, p)))\n                public_inputs := add(public_inputs, 0x40)\n            }\n\n            endpoint := add(endpoint, 0x20)\n            for {\n\n            } lt(public_inputs, endpoint) {\n                public_inputs := add(public_inputs, 0x20)\n            } {\n                let input0 := calldataload(public_inputs)\n                valid := and(valid, lt(input0, p))\n                let T0 := addmod(input0, gamma, p)\n                numerator_value := mulmod(\n                    numerator_value,\n                    add(root_1, T0), // 0x05 = coset_generator0\n                    p\n                )\n                denominator_value := mulmod(\n                    denominator_value,\n                    add(add(root_1, root_2), T0), // 0x0c = coset_generator7\n                    p\n                )\n                root_1 := mulmod(root_1, work_root, p)\n                root_2 := mulmod(root_2, work_root, p)\n            }\n        }\n        require(valid, \"public inputs are greater than circuit modulus\");\n        return (numerator_value, denominator_value);\n    }\n\n    /**\n     * @dev Computes the vanishing polynoimal and lagrange evaluations L1 and Ln.\n     * @return Returns fractions as numerators and denominators. We combine with the public input fraction and compute inverses as a batch\n     */\n    function compute_lagrange_and_vanishing_fractions(\n        Types.VerificationKey memory vk,\n        uint256 zeta\n    )\n        internal\n        pure\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 p = Bn254Crypto.r_mod;\n        uint256 vanishing_numerator = Bn254Crypto.pow_small(\n            zeta,\n            vk.circuit_size,\n            p\n        );\n        vk.zeta_pow_n = vanishing_numerator;\n        assembly {\n            vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\n        }\n\n        uint256 accumulating_root = vk.work_root_inverse;\n        uint256 work_root = vk.work_root_inverse;\n        uint256 vanishing_denominator;\n        uint256 domain_inverse = vk.domain_inverse;\n        uint256 l_start_denominator;\n        uint256 l_end_denominator;\n        uint256 z = zeta; // copy input var to prevent stack depth errors\n        assembly {\n            // vanishing_denominator = (z - w^{n-1})(z - w^{n-2})(z - w^{n-3})(z - w^{n-4})\n            // we need to cut 4 roots of unity out of the vanishing poly, the last 4 constraints are not satisfied due to randomness\n            // added to ensure the proving system is zero-knowledge\n            vanishing_denominator := addmod(z, sub(p, work_root), p)\n            work_root := mulmod(work_root, accumulating_root, p)\n            vanishing_denominator := mulmod(\n                vanishing_denominator,\n                addmod(z, sub(p, work_root), p),\n                p\n            )\n            work_root := mulmod(work_root, accumulating_root, p)\n            vanishing_denominator := mulmod(\n                vanishing_denominator,\n                addmod(z, sub(p, work_root), p),\n                p\n            )\n            work_root := mulmod(work_root, accumulating_root, p)\n            vanishing_denominator := mulmod(\n                vanishing_denominator,\n                addmod(z, sub(p, work_root), p),\n                p\n            )\n        }\n\n        work_root = vk.work_root;\n        uint256 lagrange_numerator;\n        assembly {\n            lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\n            // l_start_denominator = z - 1\n            // l_end_denominator = z * \\omega^5 - 1\n            l_start_denominator := addmod(z, sub(p, 1), p)\n\n            accumulating_root := mulmod(work_root, work_root, p)\n            accumulating_root := mulmod(accumulating_root, accumulating_root, p)\n            accumulating_root := mulmod(accumulating_root, work_root, p)\n\n            l_end_denominator := addmod(\n                mulmod(accumulating_root, z, p),\n                sub(p, 1),\n                p\n            )\n        }\n\n        return (\n            vanishing_numerator,\n            vanishing_denominator,\n            lagrange_numerator,\n            l_start_denominator,\n            l_end_denominator\n        );\n    }\n\n    function compute_arithmetic_gate_quotient_contribution(\n        Types.ChallengeTranscript memory challenges,\n        Types.Proof memory proof\n    ) internal view returns (uint256) {\n        uint256 q_arith = proof.q_arith;\n        uint256 wire3 = proof.w3;\n        uint256 wire4 = proof.w4;\n        uint256 alpha_base = challenges.alpha_base;\n        uint256 alpha = challenges.alpha;\n        uint256 t1;\n        uint256 p = Bn254Crypto.r_mod;\n        assembly {\n            t1 := addmod(mulmod(q_arith, q_arith, p), sub(p, q_arith), p)\n\n            let t2 := addmod(sub(p, mulmod(wire4, 0x04, p)), wire3, p)\n\n            let t3 := mulmod(mulmod(t2, t2, p), 0x02, p)\n\n            let t4 := mulmod(t2, 0x09, p)\n            t4 := addmod(t4, addmod(sub(p, t3), sub(p, 0x07), p), p)\n\n            t2 := mulmod(t2, t4, p)\n\n            t1 := mulmod(mulmod(t1, t2, p), alpha_base, p)\n\n            alpha_base := mulmod(alpha_base, alpha, p)\n            alpha_base := mulmod(alpha_base, alpha, p)\n        }\n\n        challenges.alpha_base = alpha_base;\n\n        return t1;\n    }\n\n    function compute_pedersen_gate_quotient_contribution(\n        Types.ChallengeTranscript memory challenges,\n        Types.Proof memory proof\n    ) internal view returns (uint256) {\n        uint256 alpha = challenges.alpha;\n        uint256 gate_id = 0;\n        uint256 alpha_base = challenges.alpha_base;\n\n        {\n            uint256 p = Bn254Crypto.r_mod;\n            uint256 delta = 0;\n\n            uint256 wire_t0 = proof.w4; // w4\n            uint256 wire_t1 = proof.w4_omega; // w4_omega\n            uint256 wire_t2 = proof.w3_omega; // w3_omega\n            assembly {\n                let wire4_neg := sub(p, wire_t0)\n                delta := addmod(wire_t1, mulmod(wire4_neg, 0x04, p), p)\n\n                gate_id := mulmod(\n                    mulmod(\n                        mulmod(\n                            mulmod(add(delta, 0x01), add(delta, 0x03), p),\n                            add(delta, sub(p, 0x01)),\n                            p\n                        ),\n                        add(delta, sub(p, 0x03)),\n                        p\n                    ),\n                    alpha_base,\n                    p\n                )\n                alpha_base := mulmod(alpha_base, alpha, p)\n\n                gate_id := addmod(\n                    gate_id,\n                    sub(p, mulmod(wire_t2, alpha_base, p)),\n                    p\n                )\n\n                alpha_base := mulmod(alpha_base, alpha, p)\n            }\n\n            uint256 selector_value = proof.q_ecc;\n\n            wire_t0 = proof.w1; // w1\n            wire_t1 = proof.w1_omega; // w1_omega\n            wire_t2 = proof.w2; // w2\n            uint256 wire_t3 = proof.w3_omega; // w3_omega\n            uint256 t0;\n            uint256 t1;\n            uint256 t2;\n            assembly {\n                t0 := addmod(wire_t1, addmod(wire_t0, wire_t3, p), p)\n\n                t1 := addmod(wire_t3, sub(p, wire_t0), p)\n                t1 := mulmod(t1, t1, p)\n\n                t0 := mulmod(t0, t1, p)\n\n                t1 := mulmod(wire_t3, mulmod(wire_t3, wire_t3, p), p)\n\n                t2 := mulmod(wire_t2, wire_t2, p)\n\n                t1 := sub(p, addmod(addmod(t1, t2, p), sub(p, 17), p))\n\n                t2 := mulmod(mulmod(delta, wire_t2, p), selector_value, p)\n                t2 := addmod(t2, t2, p)\n\n                t0 := mulmod(addmod(t0, addmod(t1, t2, p), p), alpha_base, p)\n                gate_id := addmod(gate_id, t0, p)\n\n                alpha_base := mulmod(alpha_base, alpha, p)\n            }\n\n            wire_t0 = proof.w1; // w1\n            wire_t1 = proof.w2_omega; // w2_omega\n            wire_t2 = proof.w2; // w2\n            wire_t3 = proof.w3_omega; // w3_omega\n            uint256 wire_t4 = proof.w1_omega; // w1_omega\n            assembly {\n                t0 := mulmod(\n                    addmod(wire_t1, wire_t2, p),\n                    addmod(wire_t3, sub(p, wire_t0), p),\n                    p\n                )\n\n                t1 := addmod(wire_t0, sub(p, wire_t4), p)\n\n                t2 := addmod(\n                    sub(p, mulmod(selector_value, delta, p)),\n                    wire_t2,\n                    p\n                )\n\n                gate_id := addmod(\n                    gate_id,\n                    mulmod(add(t0, mulmod(t1, t2, p)), alpha_base, p),\n                    p\n                )\n\n                alpha_base := mulmod(alpha_base, alpha, p)\n            }\n\n            selector_value = proof.q_c;\n\n            wire_t1 = proof.w4; // w4\n            wire_t2 = proof.w3; // w3\n            assembly {\n                let acc_init_id := addmod(wire_t1, sub(p, 0x01), p)\n\n                t1 := addmod(acc_init_id, sub(p, wire_t2), p)\n\n                acc_init_id := mulmod(acc_init_id, mulmod(t1, alpha_base, p), p)\n                acc_init_id := mulmod(acc_init_id, selector_value, p)\n\n                gate_id := addmod(gate_id, acc_init_id, p)\n\n                alpha_base := mulmod(alpha_base, alpha, p)\n            }\n\n            assembly {\n                let x_init_id := sub(\n                    p,\n                    mulmod(\n                        mulmod(wire_t0, selector_value, p),\n                        mulmod(wire_t2, alpha_base, p),\n                        p\n                    )\n                )\n\n                gate_id := addmod(gate_id, x_init_id, p)\n\n                alpha_base := mulmod(alpha_base, alpha, p)\n            }\n\n            wire_t0 = proof.w2; // w2\n            wire_t1 = proof.w3; // w3\n            wire_t2 = proof.w4; // w4\n            assembly {\n                let y_init_id := mulmod(\n                    add(0x01, sub(p, wire_t2)),\n                    selector_value,\n                    p\n                )\n\n                t1 := sub(p, mulmod(wire_t0, wire_t1, p))\n\n                y_init_id := mulmod(\n                    add(y_init_id, t1),\n                    mulmod(alpha_base, selector_value, p),\n                    p\n                )\n\n                gate_id := addmod(gate_id, y_init_id, p)\n\n                alpha_base := mulmod(alpha_base, alpha, p)\n            }\n            selector_value = proof.q_ecc;\n            assembly {\n                gate_id := mulmod(gate_id, selector_value, p)\n            }\n        }\n        challenges.alpha_base = alpha_base;\n        return gate_id;\n    }\n\n    function compute_permutation_quotient_contribution(\n        uint256 public_input_delta,\n        Types.ChallengeTranscript memory challenges,\n        uint256 lagrange_start,\n        uint256 lagrange_end,\n        Types.Proof memory proof\n    ) internal view returns (uint256) {\n        uint256 numerator_collector;\n        uint256 alpha = challenges.alpha;\n        uint256 beta = challenges.beta;\n        uint256 p = Bn254Crypto.r_mod;\n        uint256 grand_product = proof.grand_product_at_z_omega;\n        {\n            uint256 gamma = challenges.gamma;\n            uint256 wire1 = proof.w1;\n            uint256 wire2 = proof.w2;\n            uint256 wire3 = proof.w3;\n            uint256 wire4 = proof.w4;\n            uint256 sigma1 = proof.sigma1;\n            uint256 sigma2 = proof.sigma2;\n            uint256 sigma3 = proof.sigma3;\n            assembly {\n                let t0 := add(add(wire1, gamma), mulmod(beta, sigma1, p))\n\n                let t1 := add(add(wire2, gamma), mulmod(beta, sigma2, p))\n\n                let t2 := add(add(wire3, gamma), mulmod(beta, sigma3, p))\n\n                t0 := mulmod(t0, mulmod(t1, t2, p), p)\n\n                t0 := mulmod(t0, add(wire4, gamma), p)\n\n                t0 := mulmod(t0, grand_product, p)\n\n                t0 := mulmod(t0, alpha, p)\n\n                numerator_collector := sub(p, t0)\n            }\n        }\n\n        uint256 alpha_base = challenges.alpha_base;\n        {\n            uint256 lstart = lagrange_start;\n            uint256 lend = lagrange_end;\n            uint256 public_delta = public_input_delta;\n            assembly {\n                let alpha_squared := mulmod(alpha, alpha, p)\n                let alpha_cubed := mulmod(alpha, alpha_squared, p)\n\n                let t0 := mulmod(lstart, alpha_cubed, p)\n                let t1 := mulmod(lend, alpha_squared, p)\n                let t2 := addmod(grand_product, sub(p, public_delta), p)\n                t1 := mulmod(t1, t2, p)\n\n                numerator_collector := addmod(\n                    numerator_collector,\n                    sub(p, t0),\n                    p\n                )\n                numerator_collector := addmod(numerator_collector, t1, p)\n                alpha_base := mulmod(alpha_base, alpha_cubed, p)\n            }\n        }\n\n        challenges.alpha_base = alpha_base;\n\n        return numerator_collector;\n    }\n\n    // compute_r_0\n    function compute_linear_polynomial_constant(\n        uint256 zero_poly_inverse,\n        uint256 public_input_delta,\n        Types.ChallengeTranscript memory challenges,\n        uint256 lagrange_start,\n        uint256 lagrange_end,\n        Types.Proof memory proof\n    ) internal view returns (uint256) {\n        uint256 t0 = compute_permutation_quotient_contribution(\n            public_input_delta,\n            challenges,\n            lagrange_start,\n            lagrange_end,\n            proof\n        );\n\n        uint256 t1 = compute_arithmetic_gate_quotient_contribution(\n            challenges,\n            proof\n        );\n\n        uint256 t2 = compute_pedersen_gate_quotient_contribution(\n            challenges,\n            proof\n        );\n\n        uint256 r_0;\n        uint256 p = Bn254Crypto.r_mod;\n        assembly {\n            r_0 := addmod(t0, addmod(t1, t2, p), p)\n            // r_0 := mulmod(r_0, zero_poly_inverse, p) // not necessary for the simplified Plonk\n        }\n        return r_0;\n    }\n\n    function compute_linearised_opening_terms(\n        Types.ChallengeTranscript memory challenges,\n        uint256 L1_fr,\n        Types.VerificationKey memory vk,\n        Types.Proof memory proof\n    ) internal view returns (Types.G1Point memory) {\n        Types.G1Point\n            memory accumulator = compute_grand_product_opening_group_element(\n                proof,\n                vk,\n                challenges,\n                L1_fr\n            );\n        Types.G1Point\n            memory arithmetic_term = compute_arithmetic_selector_opening_group_element(\n                proof,\n                vk,\n                challenges\n            );\n        uint256 range_multiplier = compute_range_gate_opening_scalar(\n            proof,\n            challenges\n        );\n        uint256 logic_multiplier = compute_logic_gate_opening_scalar(\n            proof,\n            challenges\n        );\n\n        Types.G1Point memory QRANGE = vk.QRANGE;\n        Types.G1Point memory QLOGIC = vk.QLOGIC;\n        QRANGE.validateG1Point();\n        QLOGIC.validateG1Point();\n\n        // compute range_multiplier.[QRANGE] + logic_multiplier.[QLOGIC] + [accumulator] + [grand_product_term]\n        bool success;\n        assembly {\n            let mPtr := mload(0x40)\n\n            // range_multiplier.[QRANGE]\n            mstore(mPtr, mload(QRANGE))\n            mstore(add(mPtr, 0x20), mload(add(QRANGE, 0x20)))\n            mstore(add(mPtr, 0x40), range_multiplier)\n            success := staticcall(gas(), 7, mPtr, 0x60, mPtr, 0x40)\n\n            // add scalar mul output into accumulator\n            // we use mPtr to store accumulated point\n            mstore(add(mPtr, 0x40), mload(accumulator))\n            mstore(add(mPtr, 0x60), mload(add(accumulator, 0x20)))\n            success := and(\n                success,\n                staticcall(gas(), 6, mPtr, 0x80, mPtr, 0x40)\n            )\n\n            // logic_multiplier.[QLOGIC]\n            mstore(add(mPtr, 0x40), mload(QLOGIC))\n            mstore(add(mPtr, 0x60), mload(add(QLOGIC, 0x20)))\n            mstore(add(mPtr, 0x80), logic_multiplier)\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(mPtr, 0x40),\n                    0x60,\n                    add(mPtr, 0x40),\n                    0x40\n                )\n            )\n\n            // add scalar mul output into accumulator\n            success := and(\n                success,\n                staticcall(gas(), 6, mPtr, 0x80, mPtr, 0x40)\n            )\n\n            // add arithmetic into accumulator\n            mstore(add(mPtr, 0x40), mload(arithmetic_term))\n            mstore(add(mPtr, 0x60), mload(add(arithmetic_term, 0x20)))\n            success := and(\n                success,\n                staticcall(gas(), 6, mPtr, 0x80, accumulator, 0x40)\n            )\n        }\n        require(\n            success,\n            \"compute_linearised_opening_terms group operations fail\"\n        );\n\n        return accumulator;\n    }\n\n    function compute_batch_opening_commitment(\n        Types.ChallengeTranscript memory challenges,\n        Types.VerificationKey memory vk,\n        Types.G1Point memory partial_opening_commitment,\n        Types.Proof memory proof\n    ) internal view returns (Types.G1Point memory) {\n        // Computes the Kate opening proof group operations, for commitments that are not linearised\n        bool success;\n        // Reserve 0xa0 bytes of memory to perform group operations\n        uint256 accumulator_ptr;\n        uint256 p = Bn254Crypto.r_mod;\n        assembly {\n            accumulator_ptr := mload(0x40)\n            mstore(0x40, add(accumulator_ptr, 0xa0))\n        }\n        // For the simplified plonk, we need to multiply -Z_H(z) with [T1],\n        // proof.zero_poly_eval = Z_H(z)\n        uint256 zero_poly_eval_neg = p - vk.zero_polynomial_eval;\n        // [T2], [T3], [T4]\n        // first term\n        Types.G1Point memory work_point = proof.T1;\n        work_point.validateG1Point();\n        assembly {\n            mstore(accumulator_ptr, mload(work_point))\n            mstore(add(accumulator_ptr, 0x20), mload(add(work_point, 0x20)))\n            mstore(add(accumulator_ptr, 0x40), zero_poly_eval_neg)\n            // computing zero_poly_eval_neg * [T1]\n            success := staticcall(\n                gas(),\n                7,\n                accumulator_ptr,\n                0x60,\n                accumulator_ptr,\n                0x40\n            )\n        }\n\n        // second term\n        uint256 scalar_multiplier = vk.zeta_pow_n; // zeta_pow_n is computed in compute_lagrange_and_vanishing_fractions\n        uint256 zeta_n = scalar_multiplier;\n        work_point = proof.T2;\n        work_point.validateG1Point();\n        assembly {\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\n            mstore(\n                add(accumulator_ptr, 0x80),\n                mulmod(scalar_multiplier, zero_poly_eval_neg, p)\n            )\n\n            // compute zero_poly_eval_neg * zeta_n * [T2]\n            success := staticcall(\n                gas(),\n                7,\n                add(accumulator_ptr, 0x40),\n                0x60,\n                add(accumulator_ptr, 0x40),\n                0x40\n            )\n\n            // add scalar mul output into accumulator\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    accumulator_ptr,\n                    0x80,\n                    accumulator_ptr,\n                    0x40\n                )\n            )\n        }\n\n        // third term\n        work_point = proof.T3;\n        work_point.validateG1Point();\n        assembly {\n            scalar_multiplier := mulmod(scalar_multiplier, scalar_multiplier, p)\n\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\n            mstore(\n                add(accumulator_ptr, 0x80),\n                mulmod(scalar_multiplier, zero_poly_eval_neg, p)\n            )\n\n            // compute zero_poly_eval_neg * zeta_n^2 * [T3]\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(accumulator_ptr, 0x40),\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n            )\n\n            // add scalar mul output into accumulator\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    accumulator_ptr,\n                    0x80,\n                    accumulator_ptr,\n                    0x40\n                )\n            )\n        }\n\n        // fourth term\n        work_point = proof.T4;\n        work_point.validateG1Point();\n        assembly {\n            scalar_multiplier := mulmod(scalar_multiplier, zeta_n, p)\n\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\n            mstore(\n                add(accumulator_ptr, 0x80),\n                mulmod(scalar_multiplier, zero_poly_eval_neg, p)\n            )\n\n            // compute zero_poly_eval_neg * zeta_n^3 * [T4]\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(accumulator_ptr, 0x40),\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n            )\n\n            // add scalar mul output into accumulator\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    accumulator_ptr,\n                    0x80,\n                    accumulator_ptr,\n                    0x40\n                )\n            )\n        }\n\n        // fifth term\n        work_point = partial_opening_commitment;\n        work_point.validateG1Point();\n        assembly {\n            // add partial opening commitment into accumulator\n            mstore(\n                add(accumulator_ptr, 0x40),\n                mload(partial_opening_commitment)\n            )\n            mstore(\n                add(accumulator_ptr, 0x60),\n                mload(add(partial_opening_commitment, 0x20))\n            )\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    accumulator_ptr,\n                    0x80,\n                    accumulator_ptr,\n                    0x40\n                )\n            )\n        }\n\n        uint256 u_plus_one = challenges.u;\n        uint256 v_challenge = challenges.v0;\n\n        // W1\n        work_point = proof.W1;\n        work_point.validateG1Point();\n        assembly {\n            u_plus_one := addmod(u_plus_one, 0x01, p)\n\n            scalar_multiplier := mulmod(v_challenge, u_plus_one, p)\n\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\n\n            // compute v0(u + 1).[W1]\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(accumulator_ptr, 0x40),\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n            )\n\n            // add scalar mul output into accumulator\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    accumulator_ptr,\n                    0x80,\n                    accumulator_ptr,\n                    0x40\n                )\n            )\n        }\n\n        // W2\n        v_challenge = challenges.v1;\n        work_point = proof.W2;\n        work_point.validateG1Point();\n        assembly {\n            scalar_multiplier := mulmod(v_challenge, u_plus_one, p)\n\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\n\n            // compute v1(u + 1).[W2]\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(accumulator_ptr, 0x40),\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n            )\n\n            // add scalar mul output into accumulator\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    accumulator_ptr,\n                    0x80,\n                    accumulator_ptr,\n                    0x40\n                )\n            )\n        }\n\n        // W3\n        v_challenge = challenges.v2;\n        work_point = proof.W3;\n        work_point.validateG1Point();\n        assembly {\n            scalar_multiplier := mulmod(v_challenge, u_plus_one, p)\n\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\n\n            // compute v2(u + 1).[W3]\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(accumulator_ptr, 0x40),\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n            )\n\n            // add scalar mul output into accumulator\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    accumulator_ptr,\n                    0x80,\n                    accumulator_ptr,\n                    0x40\n                )\n            )\n        }\n\n        // W4\n        v_challenge = challenges.v3;\n        work_point = proof.W4;\n        work_point.validateG1Point();\n        assembly {\n            scalar_multiplier := mulmod(v_challenge, u_plus_one, p)\n\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\n\n            // compute v3(u + 1).[W4]\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(accumulator_ptr, 0x40),\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n            )\n\n            // add scalar mul output into accumulator\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    accumulator_ptr,\n                    0x80,\n                    accumulator_ptr,\n                    0x40\n                )\n            )\n        }\n\n        // SIGMA1\n        scalar_multiplier = challenges.v4;\n        work_point = vk.SIGMA1;\n        work_point.validateG1Point();\n        assembly {\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\n\n            // compute v4.[SIGMA1]\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(accumulator_ptr, 0x40),\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n            )\n\n            // add scalar mul output into accumulator\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    accumulator_ptr,\n                    0x80,\n                    accumulator_ptr,\n                    0x40\n                )\n            )\n        }\n\n        // SIGMA2\n        scalar_multiplier = challenges.v5;\n        work_point = vk.SIGMA2;\n        work_point.validateG1Point();\n        assembly {\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\n\n            // compute v5.[SIGMA2]\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(accumulator_ptr, 0x40),\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n            )\n\n            // add scalar mul output into accumulator\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    accumulator_ptr,\n                    0x80,\n                    accumulator_ptr,\n                    0x40\n                )\n            )\n        }\n\n        // SIGMA3\n        scalar_multiplier = challenges.v6;\n        work_point = vk.SIGMA3;\n        work_point.validateG1Point();\n        assembly {\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\n\n            // compute v6.[SIGMA3]\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(accumulator_ptr, 0x40),\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n            )\n\n            // add scalar mul output into accumulator\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    accumulator_ptr,\n                    0x80,\n                    accumulator_ptr,\n                    0x40\n                )\n            )\n        }\n\n        // QARITH\n        scalar_multiplier = challenges.v7;\n        work_point = vk.QARITH;\n        work_point.validateG1Point();\n        assembly {\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\n\n            // compute v7.[QARITH]\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(accumulator_ptr, 0x40),\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n            )\n\n            // add scalar mul output into accumulator\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    accumulator_ptr,\n                    0x80,\n                    accumulator_ptr,\n                    0x40\n                )\n            )\n        }\n\n        Types.G1Point memory output;\n        // QECC\n        scalar_multiplier = challenges.v8;\n        work_point = vk.QECC;\n        work_point.validateG1Point();\n        assembly {\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\n\n            // compute v8.[QECC]\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(accumulator_ptr, 0x40),\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n            )\n\n            // add scalar mul output into output point\n            success := and(\n                success,\n                staticcall(gas(), 6, accumulator_ptr, 0x80, output, 0x40)\n            )\n        }\n\n        require(\n            success,\n            \"compute_batch_opening_commitment group operations error\"\n        );\n\n        return output;\n    }\n\n    function compute_batch_evaluation_scalar_multiplier(\n        Types.Proof memory proof,\n        Types.ChallengeTranscript memory challenges\n    ) internal view returns (uint256) {\n        uint256 p = Bn254Crypto.r_mod;\n        uint256 opening_scalar;\n        uint256 lhs; // stores nu challenges\n        uint256 rhs; // stores evaluations of polynomials\n\n        lhs = challenges.v0;\n        rhs = proof.w1;\n        assembly {\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\n        }\n\n        lhs = challenges.v1;\n        rhs = proof.w2;\n        assembly {\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\n        }\n\n        lhs = challenges.v2;\n        rhs = proof.w3;\n        assembly {\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\n        }\n\n        lhs = challenges.v3;\n        rhs = proof.w4;\n        assembly {\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\n        }\n\n        lhs = challenges.v4;\n        rhs = proof.sigma1;\n        assembly {\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\n        }\n\n        lhs = challenges.v5;\n        rhs = proof.sigma2;\n        assembly {\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\n        }\n\n        lhs = challenges.v6;\n        rhs = proof.sigma3;\n        assembly {\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\n        }\n\n        lhs = challenges.v7;\n        rhs = proof.q_arith;\n        assembly {\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\n        }\n\n        lhs = challenges.v8;\n        rhs = proof.q_ecc;\n        assembly {\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\n        }\n\n        lhs = challenges.v9;\n        rhs = proof.q_c;\n        assembly {\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\n        }\n\n        // lhs = 1;    //challenges.v10; (should be -1 for simplified Plonk)\n        rhs = proof.r_0; // linearization_polynomial should be r_0 for simplified Plonk\n        assembly {\n            opening_scalar := addmod(opening_scalar, sub(p, rhs), p)\n        }\n        // should be removed for simplified Plonk\n        // lhs = proof.quotient_polynomial_eval;\n        // assembly {\n        //     opening_scalar := addmod(opening_scalar, lhs, p)\n        // }\n\n        lhs = challenges.v0;\n        rhs = proof.w1_omega;\n        uint256 shifted_opening_scalar;\n        assembly {\n            shifted_opening_scalar := mulmod(lhs, rhs, p)\n        }\n\n        lhs = challenges.v1;\n        rhs = proof.w2_omega;\n        assembly {\n            shifted_opening_scalar := addmod(\n                shifted_opening_scalar,\n                mulmod(lhs, rhs, p),\n                p\n            )\n        }\n\n        lhs = challenges.v2;\n        rhs = proof.w3_omega;\n        assembly {\n            shifted_opening_scalar := addmod(\n                shifted_opening_scalar,\n                mulmod(lhs, rhs, p),\n                p\n            )\n        }\n\n        lhs = challenges.v3;\n        rhs = proof.w4_omega;\n        assembly {\n            shifted_opening_scalar := addmod(\n                shifted_opening_scalar,\n                mulmod(lhs, rhs, p),\n                p\n            )\n        }\n\n        lhs = proof.grand_product_at_z_omega;\n        assembly {\n            shifted_opening_scalar := addmod(shifted_opening_scalar, lhs, p)\n        }\n\n        lhs = challenges.u;\n        assembly {\n            shifted_opening_scalar := mulmod(shifted_opening_scalar, lhs, p)\n\n            opening_scalar := addmod(opening_scalar, shifted_opening_scalar, p)\n        }\n\n        return opening_scalar;\n    }\n\n    // Compute kate opening scalar for arithmetic gate selectors and pedersen gate selectors\n    // (both the arithmetic gate and pedersen hash gate reuse the same selectors)\n    function compute_arithmetic_selector_opening_group_element(\n        Types.Proof memory proof,\n        Types.VerificationKey memory vk,\n        Types.ChallengeTranscript memory challenges\n    ) internal view returns (Types.G1Point memory) {\n        uint256 q_arith = proof.q_arith;\n        uint256 q_ecc = proof.q_ecc;\n        uint256 alpha_base = challenges.alpha_base;\n        uint256 scaling_alpha = challenges.alpha_base;\n        uint256 alpha = challenges.alpha;\n        uint256 p = Bn254Crypto.r_mod;\n        uint256 scalar_multiplier;\n        uint256 accumulator_ptr; // reserve 0xa0 bytes of memory to multiply and add points\n        assembly {\n            accumulator_ptr := mload(0x40)\n            mstore(0x40, add(accumulator_ptr, 0xa0))\n        }\n        {\n            uint256 delta;\n            // Q1 Selector\n            {\n                {\n                    uint256 w4 = proof.w4;\n                    uint256 w4_omega = proof.w4_omega;\n                    assembly {\n                        delta := addmod(\n                            w4_omega,\n                            sub(p, mulmod(w4, 0x04, p)),\n                            p\n                        )\n                    }\n                }\n                uint256 w1 = proof.w1;\n\n                assembly {\n                    scalar_multiplier := w1\n                    scalar_multiplier := mulmod(\n                        scalar_multiplier,\n                        alpha_base,\n                        p\n                    )\n                    scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\n\n                    scaling_alpha := mulmod(scaling_alpha, alpha, p)\n                    scaling_alpha := mulmod(scaling_alpha, alpha, p)\n                    scaling_alpha := mulmod(scaling_alpha, alpha, p)\n                    let t0 := mulmod(delta, delta, p)\n                    t0 := mulmod(t0, q_ecc, p)\n                    t0 := mulmod(t0, scaling_alpha, p)\n\n                    scalar_multiplier := addmod(scalar_multiplier, t0, p)\n                }\n                Types.G1Point memory Q1 = vk.Q1;\n                Q1.validateG1Point();\n                bool success;\n                assembly {\n                    let mPtr := mload(0x40)\n                    mstore(mPtr, mload(Q1))\n                    mstore(add(mPtr, 0x20), mload(add(Q1, 0x20)))\n                    mstore(add(mPtr, 0x40), scalar_multiplier)\n                    success := staticcall(\n                        gas(),\n                        7,\n                        mPtr,\n                        0x60,\n                        accumulator_ptr,\n                        0x40\n                    )\n                }\n                require(success, \"G1 point multiplication failed!\");\n            }\n\n            // Q2 Selector\n            {\n                uint256 w2 = proof.w2;\n                assembly {\n                    scalar_multiplier := w2\n                    scalar_multiplier := mulmod(\n                        scalar_multiplier,\n                        alpha_base,\n                        p\n                    )\n                    scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\n\n                    let t0 := mulmod(scaling_alpha, q_ecc, p)\n                    scalar_multiplier := addmod(scalar_multiplier, t0, p)\n                }\n\n                Types.G1Point memory Q2 = vk.Q2;\n                Q2.validateG1Point();\n                bool success;\n                assembly {\n                    let mPtr := mload(0x40)\n                    mstore(mPtr, mload(Q2))\n                    mstore(add(mPtr, 0x20), mload(add(Q2, 0x20)))\n                    mstore(add(mPtr, 0x40), scalar_multiplier)\n\n                    // write scalar mul output 0x40 bytes ahead of accumulator\n                    success := staticcall(\n                        gas(),\n                        7,\n                        mPtr,\n                        0x60,\n                        add(accumulator_ptr, 0x40),\n                        0x40\n                    )\n\n                    // add scalar mul output into accumulator\n                    success := and(\n                        success,\n                        staticcall(\n                            gas(),\n                            6,\n                            accumulator_ptr,\n                            0x80,\n                            accumulator_ptr,\n                            0x40\n                        )\n                    )\n                }\n                require(success, \"G1 point multiplication failed!\");\n            }\n\n            // Q3 Selector\n            {\n                {\n                    uint256 w3 = proof.w3;\n                    assembly {\n                        scalar_multiplier := w3\n                        scalar_multiplier := mulmod(\n                            scalar_multiplier,\n                            alpha_base,\n                            p\n                        )\n                        scalar_multiplier := mulmod(\n                            scalar_multiplier,\n                            q_arith,\n                            p\n                        )\n                    }\n                }\n                {\n                    uint256 t1;\n                    {\n                        uint256 w3_omega = proof.w3_omega;\n                        assembly {\n                            t1 := mulmod(delta, w3_omega, p)\n                        }\n                    }\n                    {\n                        uint256 w2 = proof.w2;\n                        assembly {\n                            scaling_alpha := mulmod(scaling_alpha, alpha, p)\n\n                            t1 := mulmod(t1, w2, p)\n                            t1 := mulmod(t1, scaling_alpha, p)\n                            t1 := addmod(t1, t1, p)\n                            t1 := mulmod(t1, q_ecc, p)\n\n                            scalar_multiplier := addmod(\n                                scalar_multiplier,\n                                t1,\n                                p\n                            )\n                        }\n                    }\n                }\n                uint256 t0 = proof.w1_omega;\n                {\n                    uint256 w1 = proof.w1;\n                    assembly {\n                        scaling_alpha := mulmod(scaling_alpha, alpha, p)\n                        t0 := addmod(t0, sub(p, w1), p)\n                        t0 := mulmod(t0, delta, p)\n                    }\n                }\n                uint256 w3_omega = proof.w3_omega;\n                assembly {\n                    t0 := mulmod(t0, w3_omega, p)\n                    t0 := mulmod(t0, scaling_alpha, p)\n\n                    t0 := mulmod(t0, q_ecc, p)\n\n                    scalar_multiplier := addmod(scalar_multiplier, t0, p)\n                }\n            }\n\n            Types.G1Point memory Q3 = vk.Q3;\n            Q3.validateG1Point();\n            bool success;\n            assembly {\n                let mPtr := mload(0x40)\n                mstore(mPtr, mload(Q3))\n                mstore(add(mPtr, 0x20), mload(add(Q3, 0x20)))\n                mstore(add(mPtr, 0x40), scalar_multiplier)\n\n                // write scalar mul output 0x40 bytes ahead of accumulator\n                success := staticcall(\n                    gas(),\n                    7,\n                    mPtr,\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n\n                // add scalar mul output into accumulator\n                success := and(\n                    success,\n                    staticcall(\n                        gas(),\n                        6,\n                        accumulator_ptr,\n                        0x80,\n                        accumulator_ptr,\n                        0x40\n                    )\n                )\n            }\n            require(success, \"G1 point multiplication failed!\");\n        }\n\n        // Q4 Selector\n        {\n            uint256 w3 = proof.w3;\n            uint256 w4 = proof.w4;\n            uint256 q_c = proof.q_c;\n            assembly {\n                scalar_multiplier := w4\n                scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\n                scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\n\n                scaling_alpha := mulmod(\n                    scaling_alpha,\n                    mulmod(alpha, alpha, p),\n                    p\n                )\n                let t0 := mulmod(w3, q_ecc, p)\n                t0 := mulmod(t0, q_c, p)\n                t0 := mulmod(t0, scaling_alpha, p)\n\n                scalar_multiplier := addmod(scalar_multiplier, t0, p)\n            }\n\n            Types.G1Point memory Q4 = vk.Q4;\n            Q4.validateG1Point();\n            bool success;\n            assembly {\n                let mPtr := mload(0x40)\n                mstore(mPtr, mload(Q4))\n                mstore(add(mPtr, 0x20), mload(add(Q4, 0x20)))\n                mstore(add(mPtr, 0x40), scalar_multiplier)\n\n                // write scalar mul output 0x40 bytes ahead of accumulator\n                success := staticcall(\n                    gas(),\n                    7,\n                    mPtr,\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n\n                // add scalar mul output into accumulator\n                success := and(\n                    success,\n                    staticcall(\n                        gas(),\n                        6,\n                        accumulator_ptr,\n                        0x80,\n                        accumulator_ptr,\n                        0x40\n                    )\n                )\n            }\n            require(success, \"G1 point multiplication failed!\");\n        }\n\n        // Q5 Selector\n        {\n            uint256 w4 = proof.w4;\n            uint256 q_c = proof.q_c;\n            assembly {\n                let neg_w4 := sub(p, w4)\n                scalar_multiplier := mulmod(w4, w4, p)\n                scalar_multiplier := addmod(scalar_multiplier, neg_w4, p)\n                scalar_multiplier := mulmod(\n                    scalar_multiplier,\n                    addmod(w4, sub(p, 2), p),\n                    p\n                )\n                scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\n                scalar_multiplier := mulmod(scalar_multiplier, alpha, p)\n                scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\n\n                let t0 := addmod(0x01, neg_w4, p)\n                t0 := mulmod(t0, q_ecc, p)\n                t0 := mulmod(t0, q_c, p)\n                t0 := mulmod(t0, scaling_alpha, p)\n\n                scalar_multiplier := addmod(scalar_multiplier, t0, p)\n            }\n\n            Types.G1Point memory Q5 = vk.Q5;\n            Q5.validateG1Point();\n            bool success;\n            assembly {\n                let mPtr := mload(0x40)\n                mstore(mPtr, mload(Q5))\n                mstore(add(mPtr, 0x20), mload(add(Q5, 0x20)))\n                mstore(add(mPtr, 0x40), scalar_multiplier)\n\n                // write scalar mul output 0x40 bytes ahead of accumulator\n                success := staticcall(\n                    gas(),\n                    7,\n                    mPtr,\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n\n                // add scalar mul output into accumulator\n                success := and(\n                    success,\n                    staticcall(\n                        gas(),\n                        6,\n                        accumulator_ptr,\n                        0x80,\n                        accumulator_ptr,\n                        0x40\n                    )\n                )\n            }\n            require(success, \"G1 point multiplication failed!\");\n        }\n\n        // QM Selector\n        {\n            {\n                uint256 w1 = proof.w1;\n                uint256 w2 = proof.w2;\n\n                assembly {\n                    scalar_multiplier := mulmod(w1, w2, p)\n                    scalar_multiplier := mulmod(\n                        scalar_multiplier,\n                        alpha_base,\n                        p\n                    )\n                    scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\n                }\n            }\n            uint256 w3 = proof.w3;\n            uint256 q_c = proof.q_c;\n            assembly {\n                scaling_alpha := mulmod(scaling_alpha, alpha, p)\n                let t0 := mulmod(w3, q_ecc, p)\n                t0 := mulmod(t0, q_c, p)\n                t0 := mulmod(t0, scaling_alpha, p)\n\n                scalar_multiplier := addmod(scalar_multiplier, t0, p)\n            }\n\n            Types.G1Point memory QM = vk.QM;\n            QM.validateG1Point();\n            bool success;\n            assembly {\n                let mPtr := mload(0x40)\n                mstore(mPtr, mload(QM))\n                mstore(add(mPtr, 0x20), mload(add(QM, 0x20)))\n                mstore(add(mPtr, 0x40), scalar_multiplier)\n\n                // write scalar mul output 0x40 bytes ahead of accumulator\n                success := staticcall(\n                    gas(),\n                    7,\n                    mPtr,\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n\n                // add scalar mul output into accumulator\n                success := and(\n                    success,\n                    staticcall(\n                        gas(),\n                        6,\n                        accumulator_ptr,\n                        0x80,\n                        accumulator_ptr,\n                        0x40\n                    )\n                )\n            }\n            require(success, \"G1 point multiplication failed!\");\n        }\n\n        Types.G1Point memory output;\n        // QC Selector\n        {\n            uint256 q_c_challenge = challenges.v9;\n            assembly {\n                scalar_multiplier := alpha_base\n                scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\n\n                // TurboPlonk requires an explicit evaluation of q_c\n                scalar_multiplier := addmod(scalar_multiplier, q_c_challenge, p)\n\n                alpha_base := mulmod(scaling_alpha, alpha, p)\n            }\n\n            Types.G1Point memory QC = vk.QC;\n            QC.validateG1Point();\n            bool success;\n            assembly {\n                let mPtr := mload(0x40)\n                mstore(mPtr, mload(QC))\n                mstore(add(mPtr, 0x20), mload(add(QC, 0x20)))\n                mstore(add(mPtr, 0x40), scalar_multiplier)\n\n                // write scalar mul output 0x40 bytes ahead of accumulator\n                success := staticcall(\n                    gas(),\n                    7,\n                    mPtr,\n                    0x60,\n                    add(accumulator_ptr, 0x40),\n                    0x40\n                )\n\n                // add scalar mul output into output point\n                success := and(\n                    success,\n                    staticcall(gas(), 6, accumulator_ptr, 0x80, output, 0x40)\n                )\n            }\n            require(success, \"G1 point multiplication failed!\");\n        }\n        challenges.alpha_base = alpha_base;\n\n        return output;\n    }\n\n    // Compute kate opening scalar for logic gate opening scalars\n    // This method evalautes the polynomial identity used to evaluate either\n    // a 2-bit AND or XOR operation in a single constraint\n    function compute_logic_gate_opening_scalar(\n        Types.Proof memory proof,\n        Types.ChallengeTranscript memory challenges\n    ) internal pure returns (uint256) {\n        uint256 identity = 0;\n        uint256 p = Bn254Crypto.r_mod;\n        {\n            uint256 delta_sum = 0;\n            uint256 delta_squared_sum = 0;\n            uint256 t0 = 0;\n            uint256 t1 = 0;\n            uint256 t2 = 0;\n            uint256 t3 = 0;\n            {\n                uint256 wire1_omega = proof.w1_omega;\n                uint256 wire1 = proof.w1;\n                assembly {\n                    t0 := addmod(wire1_omega, sub(p, mulmod(wire1, 0x04, p)), p)\n                }\n            }\n\n            {\n                uint256 wire2_omega = proof.w2_omega;\n                uint256 wire2 = proof.w2;\n                assembly {\n                    t1 := addmod(wire2_omega, sub(p, mulmod(wire2, 0x04, p)), p)\n\n                    delta_sum := addmod(t0, t1, p)\n                    t2 := mulmod(t0, t0, p)\n                    t3 := mulmod(t1, t1, p)\n                    delta_squared_sum := addmod(t2, t3, p)\n                    identity := mulmod(delta_sum, delta_sum, p)\n                    identity := addmod(identity, sub(p, delta_squared_sum), p)\n                }\n            }\n\n            uint256 t4 = 0;\n            uint256 alpha = challenges.alpha;\n\n            {\n                uint256 wire3 = proof.w3;\n                assembly {\n                    t4 := mulmod(wire3, 0x02, p)\n                    identity := addmod(identity, sub(p, t4), p)\n                    identity := mulmod(identity, alpha, p)\n                }\n            }\n\n            assembly {\n                t4 := addmod(t4, t4, p)\n                t2 := addmod(t2, sub(p, t0), p)\n                t0 := mulmod(t0, 0x04, p)\n                t0 := addmod(t2, sub(p, t0), p)\n                t0 := addmod(t0, 0x06, p)\n\n                t0 := mulmod(t0, t2, p)\n                identity := addmod(identity, t0, p)\n                identity := mulmod(identity, alpha, p)\n\n                t3 := addmod(t3, sub(p, t1), p)\n                t1 := mulmod(t1, 0x04, p)\n                t1 := addmod(t3, sub(p, t1), p)\n                t1 := addmod(t1, 0x06, p)\n\n                t1 := mulmod(t1, t3, p)\n                identity := addmod(identity, t1, p)\n                identity := mulmod(identity, alpha, p)\n\n                t0 := mulmod(delta_sum, 0x03, p)\n\n                t1 := mulmod(t0, 0x03, p)\n\n                delta_sum := addmod(t1, t1, p)\n\n                t2 := mulmod(delta_sum, 0x04, p)\n                t1 := addmod(t1, t2, p)\n\n                t2 := mulmod(delta_squared_sum, 0x03, p)\n\n                delta_squared_sum := mulmod(t2, 0x06, p)\n\n                delta_sum := addmod(t4, sub(p, delta_sum), p)\n                delta_sum := addmod(delta_sum, 81, p)\n\n                t1 := addmod(delta_squared_sum, sub(p, t1), p)\n                t1 := addmod(t1, 83, p)\n            }\n\n            {\n                uint256 wire3 = proof.w3;\n                assembly {\n                    delta_sum := mulmod(delta_sum, wire3, p)\n\n                    delta_sum := addmod(delta_sum, t1, p)\n                    delta_sum := mulmod(delta_sum, wire3, p)\n                }\n            }\n            {\n                uint256 wire4 = proof.w4;\n                assembly {\n                    t2 := mulmod(wire4, 0x04, p)\n                }\n            }\n            {\n                uint256 wire4_omega = proof.w4_omega;\n                assembly {\n                    t2 := addmod(wire4_omega, sub(p, t2), p)\n                }\n            }\n            {\n                uint256 q_c = proof.q_c;\n                assembly {\n                    t3 := addmod(t2, t2, p)\n                    t2 := addmod(t2, t3, p)\n\n                    t3 := addmod(t2, t2, p)\n                    t3 := addmod(t3, t2, p)\n\n                    t3 := addmod(t3, sub(p, t0), p)\n                    t3 := mulmod(t3, q_c, p)\n\n                    t2 := addmod(t2, t0, p)\n                    delta_sum := addmod(delta_sum, delta_sum, p)\n                    t2 := addmod(t2, sub(p, delta_sum), p)\n\n                    t2 := addmod(t2, t3, p)\n\n                    identity := addmod(identity, t2, p)\n                }\n            }\n            uint256 alpha_base = challenges.alpha_base;\n\n            assembly {\n                identity := mulmod(identity, alpha_base, p)\n            }\n        }\n        // update alpha\n        uint256 alpha_base = challenges.alpha_base;\n        uint256 alpha = challenges.alpha;\n        assembly {\n            alpha := mulmod(alpha, alpha, p)\n            alpha := mulmod(alpha, alpha, p)\n            alpha_base := mulmod(alpha_base, alpha, p)\n        }\n        challenges.alpha_base = alpha_base;\n\n        return identity;\n    }\n\n    // Compute kate opening scalar for arithmetic gate selectors\n    function compute_range_gate_opening_scalar(\n        Types.Proof memory proof,\n        Types.ChallengeTranscript memory challenges\n    ) internal pure returns (uint256) {\n        uint256 wire1 = proof.w1;\n        uint256 wire2 = proof.w2;\n        uint256 wire3 = proof.w3;\n        uint256 wire4 = proof.w4;\n        uint256 wire4_omega = proof.w4_omega;\n        uint256 alpha = challenges.alpha;\n        uint256 alpha_base = challenges.alpha_base;\n        uint256 range_acc;\n        uint256 p = Bn254Crypto.r_mod;\n        assembly {\n            let delta_1 := addmod(wire3, sub(p, mulmod(wire4, 0x04, p)), p)\n            let delta_2 := addmod(wire2, sub(p, mulmod(wire3, 0x04, p)), p)\n            let delta_3 := addmod(wire1, sub(p, mulmod(wire2, 0x04, p)), p)\n            let delta_4 := addmod(\n                wire4_omega,\n                sub(p, mulmod(wire1, 0x04, p)),\n                p\n            )\n\n            let t0 := mulmod(delta_1, delta_1, p)\n            t0 := addmod(t0, sub(p, delta_1), p)\n            let t1 := addmod(delta_1, sub(p, 2), p)\n            t0 := mulmod(t0, t1, p)\n            t1 := addmod(delta_1, sub(p, 3), p)\n            t0 := mulmod(t0, t1, p)\n            t0 := mulmod(t0, alpha_base, p)\n\n            range_acc := t0\n            alpha_base := mulmod(alpha_base, alpha, p)\n\n            t0 := mulmod(delta_2, delta_2, p)\n            t0 := addmod(t0, sub(p, delta_2), p)\n            t1 := addmod(delta_2, sub(p, 2), p)\n            t0 := mulmod(t0, t1, p)\n            t1 := addmod(delta_2, sub(p, 3), p)\n            t0 := mulmod(t0, t1, p)\n            t0 := mulmod(t0, alpha_base, p)\n            range_acc := addmod(range_acc, t0, p)\n            alpha_base := mulmod(alpha_base, alpha, p)\n\n            t0 := mulmod(delta_3, delta_3, p)\n            t0 := addmod(t0, sub(p, delta_3), p)\n            t1 := addmod(delta_3, sub(p, 2), p)\n            t0 := mulmod(t0, t1, p)\n            t1 := addmod(delta_3, sub(p, 3), p)\n            t0 := mulmod(t0, t1, p)\n            t0 := mulmod(t0, alpha_base, p)\n            range_acc := addmod(range_acc, t0, p)\n            alpha_base := mulmod(alpha_base, alpha, p)\n\n            t0 := mulmod(delta_4, delta_4, p)\n            t0 := addmod(t0, sub(p, delta_4), p)\n            t1 := addmod(delta_4, sub(p, 2), p)\n            t0 := mulmod(t0, t1, p)\n            t1 := addmod(delta_4, sub(p, 3), p)\n            t0 := mulmod(t0, t1, p)\n            t0 := mulmod(t0, alpha_base, p)\n            range_acc := addmod(range_acc, t0, p)\n            alpha_base := mulmod(alpha_base, alpha, p)\n        }\n\n        challenges.alpha_base = alpha_base;\n        return range_acc;\n    }\n\n    // Compute grand product opening scalar and perform kate verification scalar multiplication\n    function compute_grand_product_opening_group_element(\n        Types.Proof memory proof,\n        Types.VerificationKey memory vk,\n        Types.ChallengeTranscript memory challenges,\n        uint256 L1_fr\n    ) internal view returns (Types.G1Point memory) {\n        uint256 beta = challenges.beta;\n        uint256 zeta = challenges.zeta;\n        uint256 gamma = challenges.gamma;\n        uint256 p = Bn254Crypto.r_mod;\n\n        uint256 partial_grand_product;\n        uint256 sigma_multiplier;\n\n        {\n            uint256 w1 = proof.w1;\n            uint256 sigma1 = proof.sigma1;\n            assembly {\n                let witness_term := addmod(w1, gamma, p)\n                partial_grand_product := addmod(\n                    mulmod(beta, zeta, p),\n                    witness_term,\n                    p\n                )\n                sigma_multiplier := addmod(\n                    mulmod(sigma1, beta, p),\n                    witness_term,\n                    p\n                )\n            }\n        }\n        {\n            uint256 w2 = proof.w2;\n            uint256 sigma2 = proof.sigma2;\n            assembly {\n                let witness_term := addmod(w2, gamma, p)\n                partial_grand_product := mulmod(\n                    partial_grand_product,\n                    addmod(\n                        mulmod(mulmod(zeta, 0x05, p), beta, p),\n                        witness_term,\n                        p\n                    ),\n                    p\n                )\n                sigma_multiplier := mulmod(\n                    sigma_multiplier,\n                    addmod(mulmod(sigma2, beta, p), witness_term, p),\n                    p\n                )\n            }\n        }\n        {\n            uint256 w3 = proof.w3;\n            uint256 sigma3 = proof.sigma3;\n            assembly {\n                let witness_term := addmod(w3, gamma, p)\n                partial_grand_product := mulmod(\n                    partial_grand_product,\n                    addmod(\n                        mulmod(mulmod(zeta, 0x06, p), beta, p),\n                        witness_term,\n                        p\n                    ),\n                    p\n                )\n\n                sigma_multiplier := mulmod(\n                    sigma_multiplier,\n                    addmod(mulmod(sigma3, beta, p), witness_term, p),\n                    p\n                )\n            }\n        }\n        {\n            uint256 w4 = proof.w4;\n            assembly {\n                partial_grand_product := mulmod(\n                    partial_grand_product,\n                    addmod(\n                        addmod(\n                            mulmod(mulmod(zeta, 0x07, p), beta, p),\n                            gamma,\n                            p\n                        ),\n                        w4,\n                        p\n                    ),\n                    p\n                )\n            }\n        }\n        {\n            uint256 alpha_base = challenges.alpha_base;\n            uint256 alpha = challenges.alpha;\n            uint256 separator_challenge = challenges.u;\n            uint256 grand_product_at_z_omega = proof.grand_product_at_z_omega;\n            uint256 l_start = L1_fr;\n            assembly {\n                partial_grand_product := mulmod(\n                    partial_grand_product,\n                    alpha_base,\n                    p\n                )\n\n                sigma_multiplier := mulmod(\n                    sub(\n                        p,\n                        mulmod(\n                            mulmod(\n                                sigma_multiplier,\n                                grand_product_at_z_omega,\n                                p\n                            ),\n                            alpha_base,\n                            p\n                        )\n                    ),\n                    beta,\n                    p\n                )\n\n                alpha_base := mulmod(mulmod(alpha_base, alpha, p), alpha, p)\n\n                partial_grand_product := addmod(\n                    addmod(\n                        partial_grand_product,\n                        mulmod(l_start, alpha_base, p),\n                        p\n                    ),\n                    separator_challenge,\n                    p\n                )\n\n                alpha_base := mulmod(alpha_base, alpha, p)\n            }\n            challenges.alpha_base = alpha_base;\n        }\n        //Need to understand the below code:\n        Types.G1Point memory Z = proof.Z;\n        Types.G1Point memory SIGMA4 = vk.SIGMA4;\n        Types.G1Point memory accumulator;\n        Z.validateG1Point();\n        SIGMA4.validateG1Point();\n        bool success;\n        assembly {\n            let mPtr := mload(0x40)\n            mstore(mPtr, mload(Z))\n            mstore(add(mPtr, 0x20), mload(add(Z, 0x20)))\n            mstore(add(mPtr, 0x40), partial_grand_product)\n            success := staticcall(gas(), 7, mPtr, 0x60, mPtr, 0x40)\n\n            mstore(add(mPtr, 0x40), mload(SIGMA4))\n            mstore(add(mPtr, 0x60), mload(add(SIGMA4, 0x20)))\n            mstore(add(mPtr, 0x80), sigma_multiplier)\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    7,\n                    add(mPtr, 0x40),\n                    0x60,\n                    add(mPtr, 0x40),\n                    0x40\n                )\n            )\n\n            // mload(mPtr) : (partial_grand_product * [Z]).x\n            // mload(mPtr + 32) : (partial_grand_product * [Z]).y\n            // mload(mPtr + 64) : (sigma_multiplier * [SIGMA_4]).x\n            // mload(mPtr + 96) : (sigma_multiplier * [SIGMA_4]).y\n\n            success := and(\n                success,\n                staticcall(gas(), 6, mPtr, 0x80, accumulator, 0x40)\n            )\n        }\n\n        require(\n            success,\n            \"compute_grand_product_opening_scalar group operations failure\"\n        );\n        return accumulator;\n    }\n}\n\n    \n\n/**\n * @title Transcript library\n * @dev Generates Plonk random challenges\n */\nlibrary Transcript {\n    struct TranscriptData {\n        bytes32 current_challenge;\n    }\n\n    /**\n     * Compute keccak256 hash of 2 4-byte variables (circuit_size, num_public_inputs)\n     */\n    function generate_initial_challenge(\n        TranscriptData memory self,\n        uint256 circuit_size,\n        uint256 num_public_inputs\n    ) internal pure {\n        bytes32 challenge;\n        assembly {\n            let mPtr := mload(0x40)\n            mstore8(add(mPtr, 0x20), shr(24, circuit_size))\n            mstore8(add(mPtr, 0x21), shr(16, circuit_size))\n            mstore8(add(mPtr, 0x22), shr(8, circuit_size))\n            mstore8(add(mPtr, 0x23), circuit_size)\n            mstore8(add(mPtr, 0x24), shr(24, num_public_inputs))\n            mstore8(add(mPtr, 0x25), shr(16, num_public_inputs))\n            mstore8(add(mPtr, 0x26), shr(8, num_public_inputs))\n            mstore8(add(mPtr, 0x27), num_public_inputs)\n            challenge := keccak256(add(mPtr, 0x20), 0x08)\n        }\n        self.current_challenge = challenge;\n    }\n\n    /**\n     * We treat the beta challenge as a special case, because it includes the public inputs.\n     * The number of public inputs can be extremely large for rollups and we want to minimize mem consumption.\n     * => we directly allocate memory to hash the public inputs, in order to prevent the global memory pointer from increasing\n     */\n    function generate_beta_gamma_challenges(\n        TranscriptData memory self,\n        Types.ChallengeTranscript memory challenges,\n        uint256 num_public_inputs\n    ) internal pure {\n        bytes32 challenge;\n        bytes32 old_challenge = self.current_challenge;\n        uint256 p = Bn254Crypto.r_mod;\n        uint256 reduced_challenge;\n        assembly {\n            let m_ptr := mload(0x40)\n            // N.B. If the calldata ABI changes this code will need to change!\n            // We can copy all of the public inputs, followed by the wire commitments, into memory\n            // using calldatacopy\n            mstore(m_ptr, old_challenge)\n            m_ptr := add(m_ptr, 0x20)\n            let inputs_start := add(calldataload(0x04), 0x24)\n            // num_calldata_bytes = public input size + 256 bytes for the 4 wire commitments\n            let num_calldata_bytes := add(0x100, mul(num_public_inputs, 0x20))\n            calldatacopy(m_ptr, inputs_start, num_calldata_bytes)\n\n            let start := mload(0x40)\n            let length := add(num_calldata_bytes, 0x20)\n\n            challenge := keccak256(start, length)\n            reduced_challenge := mod(challenge, p)\n        }\n        challenges.beta = reduced_challenge;\n\n        // get gamma challenge by appending 1 to the beta challenge and hash\n        assembly {\n            mstore(0x00, challenge)\n            mstore8(0x20, 0x01)\n            challenge := keccak256(0, 0x21)\n            reduced_challenge := mod(challenge, p)\n        }\n        challenges.gamma = reduced_challenge;\n        self.current_challenge = challenge;\n    }\n\n    function generate_alpha_challenge(\n        TranscriptData memory self,\n        Types.ChallengeTranscript memory challenges,\n        Types.G1Point memory Z\n    ) internal pure {\n        bytes32 challenge;\n        bytes32 old_challenge = self.current_challenge;\n        uint256 p = Bn254Crypto.r_mod;\n        uint256 reduced_challenge;\n        assembly {\n            let m_ptr := mload(0x40)\n            mstore(m_ptr, old_challenge)\n            mstore(add(m_ptr, 0x20), mload(add(Z, 0x20)))\n            mstore(add(m_ptr, 0x40), mload(Z))\n            challenge := keccak256(m_ptr, 0x60)\n            reduced_challenge := mod(challenge, p)\n        }\n        challenges.alpha = reduced_challenge;\n        challenges.alpha_base = reduced_challenge;\n        self.current_challenge = challenge;\n    }\n\n    function generate_zeta_challenge(\n        TranscriptData memory self,\n        Types.ChallengeTranscript memory challenges,\n        Types.G1Point memory T1,\n        Types.G1Point memory T2,\n        Types.G1Point memory T3,\n        Types.G1Point memory T4\n    ) internal pure {\n        bytes32 challenge;\n        bytes32 old_challenge = self.current_challenge;\n        uint256 p = Bn254Crypto.r_mod;\n        uint256 reduced_challenge;\n        assembly {\n            let m_ptr := mload(0x40)\n            mstore(m_ptr, old_challenge)\n            mstore(add(m_ptr, 0x20), mload(add(T1, 0x20)))\n            mstore(add(m_ptr, 0x40), mload(T1))\n            mstore(add(m_ptr, 0x60), mload(add(T2, 0x20)))\n            mstore(add(m_ptr, 0x80), mload(T2))\n            mstore(add(m_ptr, 0xa0), mload(add(T3, 0x20)))\n            mstore(add(m_ptr, 0xc0), mload(T3))\n            mstore(add(m_ptr, 0xe0), mload(add(T4, 0x20)))\n            mstore(add(m_ptr, 0x100), mload(T4))\n            challenge := keccak256(m_ptr, 0x120)\n            reduced_challenge := mod(challenge, p)\n        }\n        challenges.zeta = reduced_challenge;\n        self.current_challenge = challenge;\n    }\n\n    /**\n     * We compute our initial nu challenge by hashing the following proof elements (with the current challenge):\n     *\n     * w1, w2, w3, w4, sigma1, sigma2, sigma3, q_arith, q_ecc, q_c, linearization_poly, grand_product_at_z_omega,\n     * w1_omega, w2_omega, w3_omega, w4_omega\n     *\n     * These values are placed linearly in the proofData, we can extract them with a calldatacopy call\n     *\n     */\n    function generate_nu_challenges(\n        TranscriptData memory self,\n        Types.ChallengeTranscript memory challenges,\n        // uint256 quotient_poly_eval,\n        uint256 num_public_inputs\n    ) internal pure {\n        uint256 p = Bn254Crypto.r_mod;\n        bytes32 current_challenge = self.current_challenge;\n        uint256 base_v_challenge;\n        uint256 updated_v;\n\n        // We want to copy SIXTEEN field elements from calldata into memory to hash\n        // But we start by adding the quotient poly evaluation to the hash transcript\n        assembly {\n            // get a calldata pointer that points to the start of the data we want to copy\n            let calldata_ptr := add(calldataload(0x04), 0x24)\n            // skip over the public inputs\n            calldata_ptr := add(calldata_ptr, mul(num_public_inputs, 0x20))\n            // There are NINE G1 group elements added into the transcript in the `beta` round, that we need to skip over\n            calldata_ptr := add(calldata_ptr, 0x240) // 9 * 0x40 = 0x240\n\n            let m_ptr := mload(0x40)\n            mstore(m_ptr, current_challenge)\n            // mstore(add(m_ptr, 0x20), quotient_poly_eval)\n            calldatacopy(add(m_ptr, 0x20), calldata_ptr, 0x1e0) // 15 * 0x20 = 0x1e0\n            base_v_challenge := keccak256(m_ptr, 0x200) // hash length = 0x200, we include the previous challenge in the hash\n            updated_v := mod(base_v_challenge, p)\n        }\n\n        // assign the first challenge value\n        challenges.v0 = updated_v;\n\n        // for subsequent challenges we iterate 10 times.\n        // At each iteration i \\in [1, 10] we compute challenges.vi = keccak256(base_v_challenge, byte(i))\n        assembly {\n            mstore(0x00, base_v_challenge)\n            mstore8(0x20, 0x01)\n            updated_v := mod(keccak256(0x00, 0x21), p)\n        }\n        challenges.v1 = updated_v;\n        assembly {\n            mstore8(0x20, 0x02)\n            updated_v := mod(keccak256(0x00, 0x21), p)\n        }\n        challenges.v2 = updated_v;\n        assembly {\n            mstore8(0x20, 0x03)\n            updated_v := mod(keccak256(0x00, 0x21), p)\n        }\n        challenges.v3 = updated_v;\n        assembly {\n            mstore8(0x20, 0x04)\n            updated_v := mod(keccak256(0x00, 0x21), p)\n        }\n        challenges.v4 = updated_v;\n        assembly {\n            mstore8(0x20, 0x05)\n            updated_v := mod(keccak256(0x00, 0x21), p)\n        }\n        challenges.v5 = updated_v;\n        assembly {\n            mstore8(0x20, 0x06)\n            updated_v := mod(keccak256(0x00, 0x21), p)\n        }\n        challenges.v6 = updated_v;\n        assembly {\n            mstore8(0x20, 0x07)\n            updated_v := mod(keccak256(0x00, 0x21), p)\n        }\n        challenges.v7 = updated_v;\n        assembly {\n            mstore8(0x20, 0x08)\n            updated_v := mod(keccak256(0x00, 0x21), p)\n        }\n        challenges.v8 = updated_v;\n        assembly {\n            mstore8(0x20, 0x09)\n            updated_v := mod(keccak256(0x00, 0x21), p)\n        }\n        challenges.v9 = updated_v;\n\n        // update the current challenge when computing the final nu challenge\n        bytes32 challenge;\n        assembly {\n            mstore8(0x20, 0x0a)\n            challenge := keccak256(0x00, 0x21)\n            updated_v := mod(challenge, p)\n        }\n        challenges.v10 = updated_v;\n\n        self.current_challenge = challenge;\n    }\n\n    function generate_separator_challenge(\n        TranscriptData memory self,\n        Types.ChallengeTranscript memory challenges,\n        Types.G1Point memory PI_Z,\n        Types.G1Point memory PI_Z_OMEGA\n    ) internal pure {\n        bytes32 challenge;\n        bytes32 old_challenge = self.current_challenge;\n        uint256 p = Bn254Crypto.r_mod;\n        uint256 reduced_challenge;\n        assembly {\n            let m_ptr := mload(0x40)\n            mstore(m_ptr, old_challenge)\n            mstore(add(m_ptr, 0x20), mload(add(PI_Z, 0x20)))\n            mstore(add(m_ptr, 0x40), mload(PI_Z))\n            mstore(add(m_ptr, 0x60), mload(add(PI_Z_OMEGA, 0x20)))\n            mstore(add(m_ptr, 0x80), mload(PI_Z_OMEGA))\n            challenge := keccak256(m_ptr, 0xa0)\n            reduced_challenge := mod(challenge, p)\n        }\n        challenges.u = reduced_challenge;\n        self.current_challenge = challenge;\n    }\n}\n \n    "
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}